{"problem_id": "p02261", "original": "#include <stdio.h>\r\ntypedef struct {\r\n  char suit;\r\n  int value;\r\n} Card;\r\nvoid swap_Card(Card *x, Card *y) {\r\n  Card temp = *x;\r\n  *x = *y;\r\n  *y = temp;\r\n}\r\nvoid BubbleSort(Card A[], int N) {\r\n  int i, j;\r\n  Card temp;\r\n  for (i = 0; i < N - 1; i++) {\r\n    for (j = N - 1; j > i; j--) {\r\n      if (A[j].value < A[j - 1].value) {\r\n        temp = A[j];\r\n        A[j] = A[j - 1];\r\n        A[j - 1] = temp;\r\n      }\r\n    }\r\n  }\r\n}\r\nvoid SelectionSort(Card A[], int N) {\r\n  int i, j;\r\n  int minj;\r\n  Card temp;\r\n  for (i = 0; i < N - 1; i++) {\r\n    minj = i;\r\n    for (j = i + 1; j < N; j++) {\r\n      if (A[j].value < A[minj].value) {\r\n        minj = j;\r\n      }\r\n    }\r\n    temp = A[i];\r\n    A[i] = A[minj];\r\n    A[minj] = temp;\r\n  }\r\n}\r\nint main() {\r\n  int N;\r\n  scanf(\"%d\\n\", &N);\r\n  int i, j;\r\n  Card BC[36];\r\n  Card SC[36];\r\n  for (i = 0; i < N; i++) {\r\n    Card c;\r\n    scanf(\"%c\", &c.suit);\r\n    scanf(\"%d \", &c.value);\r\n    BC[i] = c;\r\n    SC[i] = c;\r\n  }\r\n  BubbleSort(BC, N);\r\n  SelectionSort(SC, N);\r\n  for (i = 0; i < N - 1; i++) {\r\n    printf(\"%c%d \", BC[i].suit, BC[i].value);\r\n  }\r\n  printf(\"%c%d\\n\", BC[N - 1].suit, BC[N - 1].value);\r\n  puts(\"Stable\");\r\n  for (i = 0; i < N - 1; i++) {\r\n    printf(\"%c%d \", SC[i].suit, SC[i].value);\r\n  }\r\n  printf(\"%c%d\\n\", SC[N - 1].suit, SC[N - 1].value);\r\n  for (i = 0; i < N; i++) {\r\n    if (BC[i].suit != SC[i].suit) {\r\n      puts(\"Not stable\");\r\n      return 0;\r\n    }\r\n  }\r\n  puts(\"Stable\");\r\n  return 0;\r\n}\r\n", "diff": "@@ -11,8 +11,8 @@\n void BubbleSort(Card A[], int N) {\n   int i, j;\n   Card temp;\n-  for (i = 0; i < N - 1; i++) {\n-    for (j = N - 1; j > i; j--) {\n+  for (i = 0; i < N; i++) {\n+    for (j = N - 1; j >= i + 1; j--) {\n       if (A[j].value < A[j - 1].value) {\n         temp = A[j];\n         A[j] = A[j - 1];\n@@ -25,9 +25,9 @@\n   int i, j;\n   int minj;\n   Card temp;\n-  for (i = 0; i < N - 1; i++) {\n+  for (i = 0; i < N; i++) {\n     minj = i;\n-    for (j = i + 1; j < N; j++) {\n+    for (j = i; j < N; j++) {\n       if (A[j].value < A[minj].value) {\n         minj = j;\n       }", "predicted_diffs": [" - -34,8 +34,8 @@\n }\n int main() {\n   int N;\n+  int i, j;\n   scanf(\"%d\\n\", &N);\n-  int i, j;\n   Card BC[36];\n   Card SC[36];\n   for (i = 0; i < N; i++) {"], "optimized_codes": ["#include <stdio.h>\ntypedef struct {\n  char suit;\n  int value;\n} Card;\nvoid swap_Card(Card *x, Card *y) {\n  Card temp = *x;\n  *x = *y;\n  *y = temp;\n}\nvoid BubbleSort(Card A[], int N) {\n  int i, j;\n  Card temp;\n  for (i = 0; i < N - 1; i++) {\n    for (j = N - 1; j > i; j--) {\n      if (A[j].value < A[j - 1].value) {\n        temp = A[j];\n        A[j] = A[j - 1];\n        A[j - 1] = temp;\n      }\n    }\n  }\n}\nvoid SelectionSort(Card A[], int N) {\n  int i, j;\n  int minj;\n  Card temp;\n  for (i = 0; i < N - 1; i++) {\n    minj = i;\n    for (j = i + 1; j < N; j++) {\n      if (A[j].value < A[minj].value) {\n        minj = j;\n      }\n    }\n    temp = A[i];\n    A[i] = A[minj];\n    A[minj] = temp;\n  }\n}\nint main() {\n  int N;\n  scanf(\"%d\\n\", &N);\n  int i, j;\n  Card BC[36];\n  Card SC[36];\n  for (i = 0; i < N; i++) {\n    Card c;\n    scanf(\"%c\", &c.suit);\n    scanf(\"%d \", &c.value);\n    BC[i] = c;\n    SC[i] = c;\n  }\n  BubbleSort(BC, N);\n  SelectionSort(SC, N);\n  for (i = 0; i < N - 1; i++) {\n    printf(\"%c%d \", BC[i].suit, BC[i].value);\n  }\n  printf(\"%c%d\\n\", BC[N - 1].suit, BC[N - 1].value);\n  puts(\"Stable\");\n  for (i = 0; i < N - 1; i++) {\n    printf(\"%c%d \", SC[i].suit, SC[i].value);\n  }\n  printf(\"%c%d\\n\", SC[N - 1].suit, SC[N - 1].value);\n  for (i = 0; i < N; i++) {\n    if (BC[i].suit != SC[i].suit) {\n      puts(\"Not stable\");\n      return 0;\n    }\n  }\n  puts(\"Stable\");\n  return 0;\n}"]}
{"problem_id": "p00922", "original": "#include <algorithm>\r\n#include <climits>\r\n#include <iostream>\r\n#include <vector>\r\ntypedef std::vector<int> vec;\r\ninline bool power_of_2(int n) { return (n & (n - 1)) == 0; }\r\ninline int max_divisor(int n) { return n & -n; }\r\nint g(const vec &sequence) {\r\n  int sum = 0;\r\n  for (int i = 0; i < sequence.size(); i++) {\r\n    sum += sequence[i];\r\n  }\r\n  vec table(sum + 1);\r\n  std::fill(table.begin() + 1, table.end(), -1);\r\n  table[0] = 0;\r\n  sum = 0;\r\n  for (int i = 0; i < sequence.size(); i++) {\r\n    int x = sequence[i];\r\n    for (int a = sum & -x; a >= 0; a -= x) {\r\n      if (table[a] >= 0) {\r\n        int b = a + x;\r\n        table[b] = std::max(table[a] + 1, table[b]);\r\n      }\r\n    }\r\n    sum += sequence[i];\r\n  }\r\n  int max = 0;\r\n  for (int i = 1; i <= sum; i <<= 1) {\r\n    max = std::max(max, table[i]);\r\n  }\r\n  return max;\r\n}\r\nvec extract(const vec &sequence, int k) {\r\n  vec subsequence;\r\n  int min = INT_MAX;\r\n  for (int i = 0; i < sequence.size(); i++) {\r\n    int x = sequence[i];\r\n    std::div_t xk = std::div(x, k);\r\n    if (xk.rem == 0 && power_of_2(xk.quot)) {\r\n      subsequence.push_back(x);\r\n      min = std::min(min, x);\r\n    }\r\n  }\r\n  for (int i = 0; i < subsequence.size(); i++) {\r\n    subsequence[i] /= min;\r\n  }\r\n  return subsequence;\r\n}\r\nvoid sort_and_uniq(vec &numbers) {\r\n  std::sort(numbers.begin(), numbers.end());\r\n  numbers.erase(std::unique(numbers.begin(), numbers.end()), numbers.end());\r\n}\r\nint f(const vec &sequence) {\r\n  vec numbers;\r\n  for (int i = 0; i < sequence.size(); i++) {\r\n    int x = sequence[i];\r\n    numbers.push_back(x / max_divisor(x));\r\n  }\r\n  sort_and_uniq(numbers);\r\n  int max = 0;\r\n  for (int i = 0; i < numbers.size(); i++) {\r\n    int k = numbers[i];\r\n    const vec &subsequence = extract(sequence, k);\r\n    max = std::max(max, g(subsequence));\r\n  }\r\n  return max;\r\n}\r\nint main() {\r\n  while (true) {\r\n    int n;\r\n    std::cin >> n;\r\n    if (n == 0) {\r\n      break;\r\n    }\r\n    vec sequence(n);\r\n    for (int i = 0; i < n; i++) {\r\n      std::cin >> sequence[i];\r\n    }\r\n    std::cout << f(sequence) << std::endl;\r\n  }\r\n  return 0;\r\n}\r\n", "diff": "@@ -35,8 +35,7 @@\n   int min = INT_MAX;\n   for (int i = 0; i < sequence.size(); i++) {\n     int x = sequence[i];\n-    std::div_t xk = std::div(x, k);\n-    if (xk.rem == 0 && power_of_2(xk.quot)) {\n+    if (x % k == 0 && power_of_2(x / k)) {\n       subsequence.push_back(x);\n       min = std::min(min, x);\n     }", "predicted_diffs": [" - -3,8 +3,8 @@\n #include <iostream>\n #include <vector>\n typedef std::vector<int> vec;\n-inline bool power_of_2(int n) { return (n & (n - 1)) == 0; }\n-int max_divisor(int n) { return (~n & (n - 1)) + 1; }\n+bool power_of_2(int n) { return (n & (n - 1)) == 0; }\n+int max_divisor(int n) { return n & -n; }\n int g(const vec &sequence) {\n   int sum = 0;\n   for (int i = 0; i < sequence.size(); i++) {"], "optimized_codes": ["#include <algorithm>\n#include <climits>\n#include <iostream>\n#include <vector>\ntypedef std::vector<int> vec;\ninline bool power_of_2(int n) { return (n & (n - 1)) == 0; }\ninline int max_divisor(int n) { return n & -n; }\nint g(const vec &sequence) {\n  int sum = 0;\n  for (int i = 0; i < sequence.size(); i++) {\n    sum += sequence[i];\n  }\n  vec table(sum + 1);\n  std::fill(table.begin() + 1, table.end(), -1);\n  table[0] = 0;\n  sum = 0;\n  for (int i = 0; i < sequence.size(); i++) {\n    int x = sequence[i];\n    for (int a = sum & -x; a >= 0; a -= x) {\n      if (table[a] >= 0) {\n        int b = a + x;\n        table[b] = std::max(table[a] + 1, table[b]);\n      }\n    }\n    sum += sequence[i];\n  }\n  int max = 0;\n  for (int i = 1; i <= sum; i <<= 1) {\n    max = std::max(max, table[i]);\n  }\n  return max;\n}\nvec extract(const vec &sequence, int k) {\n  vec subsequence;\n  int min = INT_MAX;\n  for (int i = 0; i < sequence.size(); i++) {\n    int x = sequence[i];\n    std::div_t xk = std::div(x, k);\n    if (xk.rem == 0 && power_of_2(xk.quot)) {\n      subsequence.push_back(x);\n      min = std::min(min, x);\n    }\n  }\n  for (int i = 0; i < subsequence.size(); i++) {\n    subsequence[i] /= min;\n  }\n  return subsequence;\n}\nvoid sort_and_uniq(vec &numbers) {\n  std::sort(numbers.begin(), numbers.end());\n  numbers.erase(std::unique(numbers.begin(), numbers.end()), numbers.end());\n}\nint f(const vec &sequence) {\n  vec numbers;\n  for (int i = 0; i < sequence.size(); i++) {\n    int x = sequence[i];\n    numbers.push_back(x / max_divisor(x));\n  }\n  sort_and_uniq(numbers);\n  int max = 0;\n  for (int i = 0; i < numbers.size(); i++) {\n    int k = numbers[i];\n    const vec &subsequence = extract(sequence, k);\n    max = std::max(max, g(subsequence));\n  }\n  return max;\n}\nint main() {\n  while (true) {\n    int n;\n    std::cin >> n;\n    if (n == 0) {\n      break;\n    }\n    vec sequence(n);\n    for (int i = 0; i < n; i++) {\n      std::cin >> sequence[i];\n    }\n    std::cout << f(sequence) << std::endl;\n  }\n  return 0;\n}"]}
{"problem_id": "p02269", "original": "#include <stdio.h>\r\n#include <string.h>\r\n#define MAX 16777215\r\nint Hash[MAX];\r\nchar str[13];\r\nint getChar(char);\r\nint getKey();\r\nint find();\r\nvoid insert();\r\nint main() {\r\n  int n;\r\n  char com[7];\r\n  scanf(\"%d\", &n);\r\n  while (n--) {\r\n    scanf(\"%s %s\", com, str);\r\n    if (com[0] == 'i') {\r\n      insert();\r\n    } else {\r\n      if (find()) {\r\n        puts(\"yes\");\r\n      } else {\r\n        puts(\"no\");\r\n      }\r\n    }\r\n  }\r\n  return 0;\r\n}\r\nint getChar(char ch) {\r\n  if (ch == 'A') {\r\n    return 1;\r\n  } else if (ch == 'C') {\r\n    return 2;\r\n  } else if (ch == 'G') {\r\n    return 3;\r\n  }\r\n  return 4;\r\n}\r\nint getKey() {\r\n  int sum = 0, p = 1, i;\r\n  for (i = 0; i < strlen(str); i++) {\r\n    sum += p * (getChar(str[i]));\r\n    p *= 5;\r\n  }\r\n  return sum;\r\n}\r\nint find() {\r\n  int key = getKey();\r\n  if (Hash[key]) {\r\n    return 1;\r\n  }\r\n  return 0;\r\n}\r\nvoid insert() { Hash[getKey()] = 1; }\r\n", "diff": "@@ -1,6 +1,6 @@\n #include <stdio.h>\n #include <string.h>\n-#define MAX 16777215\n+#define MAX 16777000\n int Hash[MAX];\n char str[13];\n int getChar(char);", "predicted_diffs": [" - -1,6 +1,6 @@\n #include <stdio.h>\n #include <string.h>\n-#define MAX 16777216\n+#define MAX 16777215\n int Hash[MAX];\n char str[13];\n int getChar(char);"], "optimized_codes": ["#include <stdio.h>\n#include <string.h>\n#define MAX 16777215\nint Hash[MAX];\nchar str[13];\nint getChar(char);\nint getKey();\nint find();\nvoid insert();\nint main() {\n  int n;\n  char com[7];\n  scanf(\"%d\", &n);\n  while (n--) {\n    scanf(\"%s %s\", com, str);\n    if (com[0] == 'i') {\n      insert();\n    } else {\n      if (find()) {\n        puts(\"yes\");\n      } else {\n        puts(\"no\");\n      }\n    }\n  }\n  return 0;\n}\nint getChar(char ch) {\n  if (ch == 'A') {\n    return 1;\n  } else if (ch == 'C') {\n    return 2;\n  } else if (ch == 'G') {\n    return 3;\n  }\n  return 4;\n}\nint getKey() {\n  int sum = 0, p = 1, i;\n  for (i = 0; i < strlen(str); i++) {\n    sum += p * (getChar(str[i]));\n    p *= 5;\n  }\n  return sum;\n}\nint find() {\n  int key = getKey();\n  if (Hash[key]) {\n    return 1;\n  }\n  return 0;\n}\nvoid insert() { Hash[getKey()] = 1; }"]}
{"problem_id": "p00362", "original": "#include <bits/stdc++.h>\r\n#define U [1 << 17] = {}\r\ntypedef long long L;\r\nusing namespace std;\r\nmap<L, L> T U;\r\nL P U, E U, Z U, H U, C U, A U, O U, X U, B U, k, n, a, b, c, p, r;\r\nchar s U;\r\nL D(L a) {\r\n  Z[a] = 1;\r\n  for (map<L, L>::iterator I = T[a].begin(); I != T[a].end(); I++) {\r\n    L d = I->first;\r\n    d - P[a] ? P[d] = a, E[d] = E[a] + 1, C[d] = I->second, D(d), Z[a] += Z[d],\r\n               !H[a] | Z[H[a]] < Z[d] ? H[a] = d : 0 : 0;\r\n  }\r\n}\r\nL G(L a) {\r\n  r = A[a] + A[P[a]] + C[a];\r\n  return r % k ? r : 0;\r\n}\r\nL M(L i) { return i ? B[i] + M(i - (i & -i)) : 0; }\r\nL S(L x, L i) {\r\n  for (x = G(x) - M(i + 1) + M(i++); i < 1 << 17; B[i] += x, i += i & -i)\r\n    ;\r\n}\r\nL W() {\r\n  for (c = 0; p = X[a], n = X[b], p - n; a = P[p])\r\n    E[p] < E[n] ? swap(p, n), swap(a, b), 0 : 0, c += M(O[a]) - M(O[p]) + G(p);\r\n  cout << c + abs(M(O[a]) - M(O[b])) << endl;\r\n}\r\nmain() {\r\n  for (cin >> n >> k; ++p < n; T[a][b] = T[b][a] = c)\r\n    cin >> a >> b >> c;\r\n  for (D(c = p = 0); p < n; p++)\r\n    if (!p | H[P[p]] - p)\r\n      for (a = p; !c | a; S(a = H[a], O[a] = c++))\r\n        X[a] = p;\r\n  for (cin >> a; cin >> s >> a >> b;\r\n       *s & 2 ? W() : A[a] += b, S(H[a], O[a]), a ? S(a, O[a] - 1) : 0)\r\n    ;\r\n}\r\n", "diff": "@@ -6,9 +6,10 @@\n L P U, E U, Z U, H U, C U, A U, O U, X U, B U, k, n, a, b, c, p, r;\n char s U;\n L D(L a) {\n+  L d;\n   Z[a] = 1;\n-  for (map<L, L>::iterator I = T[a].begin(); I != T[a].end(); I++) {\n-    L d = I->first;\n+  for (map<L, L>::iterator I = T[a].begin(); d = I->first, I != T[a].end();\n+       I++) {\n     d - P[a] ? P[d] = a, E[d] = E[a] + 1, C[d] = I->second, D(d), Z[a] += Z[d],\n                !H[a] | Z[H[a]] < Z[d] ? H[a] = d : 0 : 0;\n   }", "predicted_diffs": [" - -8,10 +8,9 @@\n L D(L a) {\n   L d;\n   Z[a] = 1;\n-  for (map<L, L>::iterator I = T[a].begin(); I != T[a].end(); I++) {\n+  for (map<L, L>::iterator I = T[a].begin(); I != T[a].end(); I++)\n     d = I->first, d - P[a] ? P[d] = a, E[d] = E[a] + 1, C[d] = I->second, D(d),\n     Z[a] += Z[d], !H[a] | Z[H[a]] < Z[d] ? H[a] = d : 0 : 0;\n-  }\n }\n L G(L a) {\n   r = A[a] + A[P[a]] + C[a];"], "optimized_codes": ["#include <bits/stdc++.h>\n#define U [1 << 17] = {}\ntypedef long long L;\nusing namespace std;\nmap<L, L> T U;\nL P U, E U, Z U, H U, C U, A U, O U, X U, B U, k, n, a, b, c, p, r;\nchar s U;\nL D(L a) {\n  Z[a] = 1;\n  for (map<L, L>::iterator I = T[a].begin(); I != T[a].end(); I++) {\n    L d = I->first;\n    d - P[a] ? P[d] = a, E[d] = E[a] + 1, C[d] = I->second, D(d), Z[a] += Z[d],\n               !H[a] | Z[H[a]] < Z[d] ? H[a] = d : 0 : 0;\n  }\n}\nL G(L a) {\n  r = A[a] + A[P[a]] + C[a];\n  return r % k ? r : 0;\n}\nL M(L i) { return i ? B[i] + M(i - (i & -i)) : 0; }\nL S(L x, L i) {\n  for (x = G(x) - M(i + 1) + M(i++); i < 1 << 17; B[i] += x, i += i & -i)\n    ;\n}\nL W() {\n  for (c = 0; p = X[a], n = X[b], p - n; a = P[p])\n    E[p] < E[n] ? swap(p, n), swap(a, b), 0 : 0, c += M(O[a]) - M(O[p]) + G(p);\n  cout << c + abs(M(O[a]) - M(O[b])) << endl;\n}\nmain() {\n  for (cin >> n >> k; ++p < n; T[a][b] = T[b][a] = c)\n    cin >> a >> b >> c;\n  for (D(c = p = 0); p < n; p++)\n    if (!p | H[P[p]] - p)\n      for (a = p; !c | a; S(a = H[a], O[a] = c++))\n        X[a] = p;\n  for (cin >> a; cin >> s >> a >> b;\n       *s & 2 ? W() : A[a] += b, S(H[a], O[a]), a ? S(a, O[a] - 1) : 0)\n    ;\n}"]}
{"problem_id": "p00645", "original": "#include <algorithm>\r\n#include <cstdio>\r\n#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\nint main() {\r\n  vector<int> close((1 << (5 * 5)) / 32, 0);\r\n  vector<int> cls(1000000);\r\n  for (int n; scanf(\"%d\", &n), !(n == 0);) {\r\n    vector<vector<int>> pats(33);\r\n    vector<vector<int>> tmp(n, vector<int>(n, 0));\r\n    for (int i = 0; i < n; i++) {\r\n      for (int j = 0; j < n; j++) {\r\n        for (int k = i; k < n; k++) {\r\n          for (int l = j; l < n; l++) {\r\n            for (int a = i; a <= k; a++)\r\n              for (int b = j; b <= l; b++)\r\n                tmp[a][b] = 1;\r\n            int bd = 0;\r\n            for (int a = 0; a < n; a++) {\r\n              for (int b = 0; b < n; b++) {\r\n                bd = (bd << 1) | tmp[a][b];\r\n              }\r\n            }\r\n            pats[__builtin_clz(bd)].push_back(bd);\r\n            for (int a = i; a <= k; a++)\r\n              for (int b = j; b <= l; b++)\r\n                tmp[a][b] = 0;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    int bd = 0;\r\n    for (int i = 0; i < n; i++) {\r\n      for (int j = 0; j < n; j++) {\r\n        int t;\r\n        scanf(\"%d\", &t);\r\n        bd = (bd << 1) | t;\r\n      }\r\n    }\r\n    int cls_cnt = 0, cls_cur = 0;\r\n    close[bd >> 5] |= (1 << (bd & 31));\r\n    cls[cls_cnt++] = bd;\r\n    for (;;) {\r\n      int dep = cls[cls_cur] >> 25;\r\n      int cbd = cls[cls_cur] & 0x1ffffff;\r\n      cls_cur++;\r\n      const vector<int> &ps = pats[__builtin_clz(cbd)];\r\n      int sz = ps.size();\r\n      for (int i = 0; i < sz; i++) {\r\n        int nbd = cbd ^ ps[i];\r\n        if (close[nbd >> 5] & (1 << (nbd & 31)))\r\n          continue;\r\n        close[nbd >> 5] |= (1 << (nbd & 31));\r\n        cls[cls_cnt++] = ((dep + 1) << 25) | nbd;\r\n        if (nbd == 0) {\r\n          for (int i = 0; i <= dep; i++)\r\n            printf(\"myon\");\r\n          puts(\"\");\r\n          goto _exit;\r\n        }\r\n      }\r\n    }\r\n  _exit:;\r\n    {\r\n      int i = 0;\r\n      for (; i + 3 < cls_cnt; i += 4) {\r\n        close[(cls[i + 0] & 0x1ffffff) >> 5] = 0;\r\n        close[(cls[i + 1] & 0x1ffffff) >> 5] = 0;\r\n        close[(cls[i + 2] & 0x1ffffff) >> 5] = 0;\r\n        close[(cls[i + 3] & 0x1ffffff) >> 5] = 0;\r\n      }\r\n      for (; i < cls_cnt; i++)\r\n        close[(cls[i] & 0x1ffffff) >> 5] = 0;\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n", "diff": "@@ -4,11 +4,11 @@\n #include <vector>\n using namespace std;\n int main() {\n-  vector<int> close((1 << (5 * 5)) / 32, 0);\n-  vector<int> cls(1000000);\n+  static int close[(1 << (5 * 5)) / 32];\n+  static int cls[1000000];\n   for (int n; scanf(\"%d\", &n), !(n == 0);) {\n     vector<vector<int>> pats(33);\n-    vector<vector<int>> tmp(n, vector<int>(n, 0));\n+    static int tmp[5][5];\n     for (int i = 0; i < n; i++) {\n       for (int j = 0; j < n; j++) {\n         for (int k = i; k < n; k++) {", "predicted_diffs": [" - -3,12 +3,7 @@\n #include <queue>\n #include <vector>\n using namespace std;\n-int cls(int x) {\n-  int ret = 0;\n-  while (x > 0)\n-    ret++, x /= 2;\n-  return ret;\n-}\n+inline int cls(int x) { return 32 - __builtin_clz(x); }\n int main() {\n   vector<bool> close(1 << (5 * 5), false);\n   vector<int> cls;"], "optimized_codes": ["#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  vector<int> close((1 << (5 * 5)) / 32, 0);\n  vector<int> cls(1000000);\n  for (int n; scanf(\"%d\", &n), !(n == 0);) {\n    vector<vector<int>> pats(33);\n    vector<vector<int>> tmp(n, vector<int>(n, 0));\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        for (int k = i; k < n; k++) {\n          for (int l = j; l < n; l++) {\n            for (int a = i; a <= k; a++)\n              for (int b = j; b <= l; b++)\n                tmp[a][b] = 1;\n            int bd = 0;\n            for (int a = 0; a < n; a++) {\n              for (int b = 0; b < n; b++) {\n                bd = (bd << 1) | tmp[a][b];\n              }\n            }\n            pats[__builtin_clz(bd)].push_back(bd);\n            for (int a = i; a <= k; a++)\n              for (int b = j; b <= l; b++)\n                tmp[a][b] = 0;\n          }\n        }\n      }\n    }\n    int bd = 0;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        int t;\n        scanf(\"%d\", &t);\n        bd = (bd << 1) | t;\n      }\n    }\n    int cls_cnt = 0, cls_cur = 0;\n    close[bd >> 5] |= (1 << (bd & 31));\n    cls[cls_cnt++] = bd;\n    for (;;) {\n      int dep = cls[cls_cur] >> 25;\n      int cbd = cls[cls_cur] & 0x1ffffff;\n      cls_cur++;\n      const vector<int> &ps = pats[__builtin_clz(cbd)];\n      int sz = ps.size();\n      for (int i = 0; i < sz; i++) {\n        int nbd = cbd ^ ps[i];\n        if (close[nbd >> 5] & (1 << (nbd & 31)))\n          continue;\n        close[nbd >> 5] |= (1 << (nbd & 31));\n        cls[cls_cnt++] = ((dep + 1) << 25) | nbd;\n        if (nbd == 0) {\n          for (int i = 0; i <= dep; i++)\n            printf(\"myon\");\n          puts(\"\");\n          goto _exit;\n        }\n      }\n    }\n  _exit:;\n    {\n      int i = 0;\n      for (; i + 3 < cls_cnt; i += 4) {\n        close[(cls[i + 0] & 0x1ffffff) >> 5] = 0;\n        close[(cls[i + 1] & 0x1ffffff) >> 5] = 0;\n        close[(cls[i + 2] & 0x1ffffff) >> 5] = 0;\n        close[(cls[i + 3] & 0x1ffffff) >> 5] = 0;\n      }\n      for (; i < cls_cnt; i++)\n        close[(cls[i] & 0x1ffffff) >> 5] = 0;\n    }\n  }\n  return 0;\n}"]}
{"problem_id": "p01349", "original": "#include <algorithm>\r\n#include <iostream>\r\n#include <map>\r\n#include <queue>\r\n#include <string>\r\n#include <vector>\r\n#define all(c) c.begin(), c.end()\r\n#define pb push_back\r\nusing namespace std;\r\nint h, w, n;\r\nvector<string> st(vector<string> s, vector<vector<bool>> f) {\r\n  for (int i = 0; i < w; i++) {\r\n    string t = \"\";\r\n    for (int j = h - 1; j >= 0; j--) {\r\n      if (isalpha(s[j][i]) && !f[j][i]) {\r\n        t += s[j][i];\r\n      }\r\n    }\r\n    for (int j = 0; j < t.size(); j++) {\r\n      s[h - 1 - j][i] = t[j];\r\n    }\r\n    for (int j = t.size(); j < h; j++) {\r\n      s[h - 1 - j][i] = '.';\r\n    }\r\n  }\r\n  return s;\r\n}\r\nbool ret(vector<string> s, int cnt) {\r\n  vector<vector<bool>> f(h, vector<bool>(w));\r\n  int sum = 0;\r\n  for (int i = 0; i < h; i++) {\r\n    for (int j = 0; j < w - 1; j++) {\r\n      if (!isalpha(s[i][j]))\r\n        continue;\r\n      int a = 1;\r\n      for (int k = j; k < w - 1; k++) {\r\n        if (s[i][k] == s[i][k + 1]) {\r\n          a++;\r\n        } else\r\n          break;\r\n      }\r\n      if (a >= n) {\r\n        for (int k = 0; k < a; k++) {\r\n          if (!f[i][k + j]) {\r\n            sum++;\r\n          }\r\n          f[i][k + j] = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  for (int i = 0; i < w; i++) {\r\n    for (int j = 0; j < h - 1; j++) {\r\n      if (!isalpha(s[j][i]))\r\n        continue;\r\n      int a = 1;\r\n      for (int k = j; k < h - 1; k++) {\r\n        if (s[k][i] == s[k + 1][i]) {\r\n          a++;\r\n        } else\r\n          break;\r\n      }\r\n      if (a >= n) {\r\n        for (int k = 0; k < a; k++) {\r\n          if (!f[k + j][i]) {\r\n            sum++;\r\n          }\r\n          f[k + j][i] = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (cnt - sum == 0)\r\n    return true;\r\n  if (!sum)\r\n    return false;\r\n  return ret(st(s, f), cnt - sum);\r\n}\r\nint main() {\r\n  while (cin >> h >> w >> n) {\r\n    int cnt = 0;\r\n    vector<string> s(h);\r\n    for (int i = 0; i < h; i++) {\r\n      cin >> s[i];\r\n      for (int j = 0; j < w; j++) {\r\n        if (s[i][j] != '.')\r\n          cnt++;\r\n      }\r\n    }\r\n    bool flag = false;\r\n    for (int i = 0; i < h; i++) {\r\n      for (int j = 0; j < w - 1; j++) {\r\n        swap(s[i][j], s[i][j + 1]);\r\n        flag = ret(st(s, vector<vector<bool>>(h, vector<bool>(w))), cnt);\r\n        if (flag) {\r\n          cout << \"YES\" << endl;\r\n          break;\r\n        }\r\n        swap(s[i][j], s[i][j + 1]);\r\n      }\r\n      if (flag)\r\n        break;\r\n    }\r\n    if (!flag)\r\n      cout << \"NO\" << endl;\r\n  }\r\n  return 0;\r\n}\r\n", "diff": "@@ -90,6 +90,8 @@\n     bool flag = false;\n     for (int i = 0; i < h; i++) {\n       for (int j = 0; j < w - 1; j++) {\n+        if (s[i][j] == s[i][j + 1])\n+          continue;\n         swap(s[i][j], s[i][j + 1]);\n         flag = ret(st(s, vector<vector<bool>>(h, vector<bool>(w))), cnt);\n         if (flag) {", "predicted_diffs": [" - -77,7 +77,7 @@\n       for (int j = 0; j < w; j++) {\n         if (i == j)\n           continue;\n-        if (isalpha(s[i][j])) {\n+        if (isalpha(s[i][j])) {\n           int sum = f[j][i];\n           for (int k = 0; k < h; k++) {\n             if (s[i][j] == s[j][k]) {"], "optimized_codes": ["#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#define all(c) c.begin(), c.end()\n#define pb push_back\nusing namespace std;\nint h, w, n;\nvector<string> st(vector<string> s, vector<vector<bool>> f) {\n  for (int i = 0; i < w; i++) {\n    string t = \"\";\n    for (int j = h - 1; j >= 0; j--) {\n      if (isalpha(s[j][i]) && !f[j][i]) {\n        t += s[j][i];\n      }\n    }\n    for (int j = 0; j < t.size(); j++) {\n      s[h - 1 - j][i] = t[j];\n    }\n    for (int j = t.size(); j < h; j++) {\n      s[h - 1 - j][i] = '.';\n    }\n  }\n  return s;\n}\nbool ret(vector<string> s, int cnt) {\n  vector<vector<bool>> f(h, vector<bool>(w));\n  int sum = 0;\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w - 1; j++) {\n      if (!isalpha(s[i][j]))\n        continue;\n      int a = 1;\n      for (int k = j; k < w - 1; k++) {\n        if (s[i][k] == s[i][k + 1]) {\n          a++;\n        } else\n          break;\n      }\n      if (a >= n) {\n        for (int k = 0; k < a; k++) {\n          if (!f[i][k + j]) {\n            sum++;\n          }\n          f[i][k + j] = true;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < w; i++) {\n    for (int j = 0; j < h - 1; j++) {\n      if (!isalpha(s[j][i]))\n        continue;\n      int a = 1;\n      for (int k = j; k < h - 1; k++) {\n        if (s[k][i] == s[k + 1][i]) {\n          a++;\n        } else\n          break;\n      }\n      if (a >= n) {\n        for (int k = 0; k < a; k++) {\n          if (!f[k + j][i]) {\n            sum++;\n          }\n          f[k + j][i] = true;\n        }\n      }\n    }\n  }\n  if (cnt - sum == 0)\n    return true;\n  if (!sum)\n    return false;\n  return ret(st(s, f), cnt - sum);\n}\nint main() {\n  while (cin >> h >> w >> n) {\n    int cnt = 0;\n    vector<string> s(h);\n    for (int i = 0; i < h; i++) {\n      cin >> s[i];\n      for (int j = 0; j < w; j++) {\n        if (s[i][j] != '.')\n          cnt++;\n      }\n    }\n    bool flag = false;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w - 1; j++) {\n        swap(s[i][j], s[i][j + 1]);\n        flag = ret(st(s, vector<vector<bool>>(h, vector<bool>(w))), cnt);\n        if (flag) {\n          cout << \"YES\" << endl;\n          break;\n        }\n        swap(s[i][j], s[i][j + 1]);\n      }\n      if (flag)\n        break;\n    }\n    if (!flag)\n      cout << \"NO\" << endl;\n  }\n  return 0;\n}"]}
{"problem_id": "p00265", "original": "#include <algorithm>\r\n#include <cmath>\r\n#include <complex>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <functional>\r\n#include <iostream>\r\n#include <map>\r\n#include <queue>\r\n#include <set>\r\n#include <sstream>\r\n#include <stack>\r\n#include <string>\r\n#include <vector>\r\nusing namespace std;\r\ntypedef pair<int, int> P;\r\ntypedef long long ll;\r\ntypedef vector<int> vi;\r\ntypedef vector<ll> vll;\r\n#define pu push\r\n#define pb push_back\r\n#define mp make_pair\r\n#define eps 1e-9\r\n#define INF 2000000000\r\n#define sz(x) ((int)(x).size())\r\n#define fi first\r\n#define sec second\r\n#define SORT(x) sort((x).begin(), (x).end())\r\n#define all(x) (x).begin(), (x).end()\r\n#define EQ(a, b) (abs((a) - (b)) < EPS)\r\nbool c[300010];\r\nint N, Q, maxc = -1, ans = 0;\r\nint s[300010];\r\nint main() {\r\n  cin >> N >> Q;\r\n  for (int i = 0; i < N; i++) {\r\n    int a;\r\n    cin >> a;\r\n    maxc = max(maxc, a);\r\n    c[a] = true;\r\n  }\r\n  for (int i = 0; i <= maxc; i++) {\r\n    if (c[i])\r\n      s[i + 1] = i;\r\n    else\r\n      s[i + 1] = s[i];\r\n  }\r\n  for (int i = 0; i < Q; i++) {\r\n    int q;\r\n    cin >> q;\r\n    ans = 0;\r\n    for (int d = maxc; maxc;) {\r\n      int p = d % q;\r\n      ans = max(ans, p);\r\n      if (d - p <= 0)\r\n        break;\r\n      d = s[d - p];\r\n    }\r\n    cout << ans << endl;\r\n  }\r\n  return 0;\r\n}\r\n", "diff": "@@ -50,7 +50,7 @@\n     int q;\n     cin >> q;\n     ans = 0;\n-    for (int d = maxc; maxc;) {\n+    for (int d = maxc;;) {\n       int p = d % q;\n       ans = max(ans, p);\n       if (d - p <= 0)", "predicted_diffs": [" - -34,13 +34,9 @@\n     int maxc = 0, minr = maxi;\n     bool s[300010];\n     for (int i = 0; i < Q; i++) {\n-      cin >> s[i];\n+      scanf(\"%d\", &s[i]);\n       maxc = max(maxc, s[i]);\n     }\n     minc = -1;\n     for (int i = 0; i < N; i++) {\n-      cin >> a[i];\n+      scanf(\"%d\", &a[i]);\n       s[i] = true;\n     }\n     if (s[i])"], "optimized_codes": ["#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(), (x).end())\n#define all(x) (x).begin(), (x).end()\n#define EQ(a, b) (abs((a) - (b)) < EPS)\nbool c[300010];\nint N, Q, maxc = -1, ans = 0;\nint s[300010];\nint main() {\n  cin >> N >> Q;\n  for (int i = 0; i < N; i++) {\n    int a;\n    cin >> a;\n    maxc = max(maxc, a);\n    c[a] = true;\n  }\n  for (int i = 0; i <= maxc; i++) {\n    if (c[i])\n      s[i + 1] = i;\n    else\n      s[i + 1] = s[i];\n  }\n  for (int i = 0; i < Q; i++) {\n    int q;\n    cin >> q;\n    ans = 0;\n    for (int d = maxc; maxc;) {\n      int p = d % q;\n      ans = max(ans, p);\n      if (d - p <= 0)\n        break;\n      d = s[d - p];\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"]}
{"problem_id": "p02242", "original": "#include <iostream>\r\nusing namespace std;\r\nstatic const int MAX = 100;\r\nstatic const int INFTY = (1 << 21);\r\nstatic const int WHITE = 0;\r\nstatic const int GRAY = 1;\r\nstatic const int BLACK = 2;\r\nint n, M[MAX][MAX];\r\nvoid dijkstra() {\r\n  int minv;\r\n  int d[MAX], color[MAX];\r\n  for (int i = 0; i < n; i++) {\r\n    d[i] = INFTY;\r\n    color[i] = WHITE;\r\n  }\r\n  d[0] = 0;\r\n  color[0] = GRAY;\r\n  while (1) {\r\n    minv = INFTY;\r\n    int u = -1;\r\n    for (int i = 0; i < n; i++) {\r\n      if (minv > d[i] && color[i] != BLACK) {\r\n        u = i;\r\n        minv = d[i];\r\n      }\r\n    }\r\n    if (u == -1)\r\n      break;\r\n    color[u] = BLACK;\r\n    for (int v = 0; v < n; v++) {\r\n      if (color[v] != BLACK && M[u][v] != INFTY) {\r\n        if (d[v] > d[u] + M[u][v]) {\r\n          d[v] = d[u] + M[u][v];\r\n          color[v] = GRAY;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  for (int i = 0; i < n; i++) {\r\n    cout << i << \" \" << (d[i] == INFTY ? -1 : d[i]) << endl;\r\n  }\r\n}\r\nint main() {\r\n  cin >> n;\r\n  for (int i = 0; i < n; i++) {\r\n    for (int j = 0; j < n; j++) {\r\n      M[i][j] = INFTY;\r\n    }\r\n  }\r\n  int k, c, u, v;\r\n  for (int i = 0; i < n; i++) {\r\n    cin >> u >> k;\r\n    for (int j = 0; j < k; j++) {\r\n      cin >> v >> c;\r\n      M[u][v] = c;\r\n    }\r\n  }\r\n  dijkstra();\r\n}\r\n", "diff": "@@ -14,7 +14,6 @@\n     color[i] = WHITE;\n   }\n   d[0] = 0;\n-  color[0] = GRAY;\n   while (1) {\n     minv = INFTY;\n     int u = -1;", "predicted_diffs": [" - -8,7 +8,7 @@\n int n, M[MAX][MAX];\n void dijkstra() {\n   int minv;\n-  int d[MAX], color[MAX];\n+  int color[MAX], d[MAX];\n   for (int i = 0; i < n; i++) {\n     d[i] = INFTY;\n     color[i] = WHITE;\n@@ -20,8 +20,8 @@\n     int u = -1;\n     for (int i = 0; i < n; i++) {\n       if (minv > d[i] && color[i] != BLACK) {\n+        minv = d[i];\n         u = i;\n-        minv = d[i];\n       }\n     }\n     if (u == -1)\n@@ -42,12 +42,12 @@\n }\n int main() {\n   cin >> n;\n+  int u, k, c, v;\n   for (int i = 0; i < n; i++) {\n-    for (int j = 0; j < MAX; j++) {\n+    for (int j = 0; j < n; j++) {\n       M[i][j] = INFTY;\n     }\n   }\n-  int k, c, u, v;\n   for (int i = 0; i < n; i++) {\n     cin >> u >> k;\n     for (int j = 0; j < k; j++) {"], "optimized_codes": ["#include <iostream>\nusing namespace std;\nstatic const int MAX = 100;\nstatic const int INFTY = (1 << 21);\nstatic const int WHITE = 0;\nstatic const int GRAY = 1;\nstatic const int BLACK = 2;\nint n, M[MAX][MAX];\nvoid dijkstra() {\n  int minv;\n  int d[MAX], color[MAX];\n  for (int i = 0; i < n; i++) {\n    d[i] = INFTY;\n    color[i] = WHITE;\n  }\n  d[0] = 0;\n  color[0] = GRAY;\n  while (1) {\n    minv = INFTY;\n    int u = -1;\n    for (int i = 0; i < n; i++) {\n      if (minv > d[i] && color[i] != BLACK) {\n        minv = d[i];\n        u = i;\n      }\n    }\n    if (u == -1)\n      break;\n    color[u] = BLACK;\n    for (int v = 0; v < n; v++) {\n      if (color[v] != BLACK && M[u][v] != INFTY) {\n        if (d[v] > d[u] + M[u][v]) {\n          d[v] = d[u] + M[u][v];\n          color[v] = GRAY;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    cout << i << \" \" << (d[i] == INFTY ? -1 : d[i]) << endl;\n  }\n}\nint main() {\n  cin >> n;\n  int u, k, c, v;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      M[i][j] = INFTY;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> u >> k;\n    for (int j = 0; j < k; j++) {\n      cin >> v >> c;\n      M[u][v] = c;\n    }\n  }\n  dijkstra();\n}"]}
{"problem_id": "p01849", "original": "#include <algorithm>\r\n#include <cfloat>\r\n#include <cmath>\r\n#include <iostream>\r\n#include <map>\r\n#include <queue>\r\n#include <set>\r\n#include <stack>\r\n#include <stdio.h>\r\n#include <string>\r\n#include <vector>\r\ntypedef long long int ll;\r\ntypedef unsigned long long int ull;\r\n#define BIG_NUM 2000000000\r\n#define MOD 1000000007\r\n#define EPS 0.000000001\r\nusing namespace std;\r\nstruct Info {\r\n  bool operator<(const struct Info &arg) const {\r\n    return sum_cost < arg.sum_cost;\r\n  };\r\n  int array[16];\r\n  int state, sum_cost, used_num;\r\n};\r\nint N, M;\r\nint POW[17];\r\nint dp[65536];\r\nint futon[16], demand[101];\r\nvoid func() {\r\n  futon[0] = 0;\r\n  for (int i = 1; i <= N; i++)\r\n    scanf(\"%d\", &futon[i]);\r\n  demand[0] = 0;\r\n  for (int i = 1; i <= M; i++)\r\n    scanf(\"%d\", &demand[i]);\r\n  sort(demand, demand + (M + 1));\r\n  N++;\r\n  for (int i = 0; i < POW[N]; i++)\r\n    dp[i] = BIG_NUM;\r\n  Info first;\r\n  first.state = 0;\r\n  first.used_num = 0;\r\n  first.sum_cost = 0;\r\n  priority_queue<Info> Q;\r\n  Q.push(first);\r\n  int tmp_sum, next_state;\r\n  while (!Q.empty()) {\r\n    if (Q.top().used_num == N) {\r\n      Q.pop();\r\n    } else if (Q.top().sum_cost > dp[Q.top().state]) {\r\n      Q.pop();\r\n    } else {\r\n      for (int loop = 0; loop < N; loop++) {\r\n        if (Q.top().state & (1 << loop)) {\r\n        } else {\r\n          Info next_info;\r\n          for (int i = 0; i < Q.top().used_num; i++)\r\n            next_info.array[i] = Q.top().array[i];\r\n          next_info.array[Q.top().used_num] = futon[loop];\r\n          if (Q.top().used_num > 0) {\r\n            next_info.array[Q.top().used_num] +=\r\n                next_info.array[Q.top().used_num - 1];\r\n          }\r\n          int index = 0;\r\n          tmp_sum = 0;\r\n          for (int i = 1; i <= M; i++) {\r\n            while (index < Q.top().used_num &&\r\n                   abs(demand[i] - next_info.array[index]) >\r\n                       abs(demand[i] - next_info.array[index + 1]))\r\n              index++;\r\n            tmp_sum += abs(demand[i] - next_info.array[index]);\r\n          }\r\n          next_state = Q.top().state + POW[loop];\r\n          if (dp[next_state] > tmp_sum) {\r\n            dp[next_state] = tmp_sum;\r\n            next_info.state = next_state;\r\n            next_info.sum_cost = tmp_sum;\r\n            next_info.used_num = Q.top().used_num + 1;\r\n            Q.push(next_info);\r\n          }\r\n        }\r\n      }\r\n      Q.pop();\r\n    }\r\n  }\r\n  printf(\"%d\\n\", dp[POW[N] - 1]);\r\n}\r\nint main() {\r\n  for (int i = 0; i < 17; i++)\r\n    POW[i] = pow(2, i);\r\n  while (true) {\r\n    scanf(\"%d %d\", &N, &M);\r\n    if (N == 0 && M == 0)\r\n      break;\r\n    func();\r\n  }\r\n  return 0;\r\n}\r\n", "diff": "@@ -17,7 +17,7 @@\n using namespace std;\n struct Info {\n   bool operator<(const struct Info &arg) const {\n-    return sum_cost < arg.sum_cost;\n+    return used_num > arg.used_num;\n   };\n   int array[16];\n   int state, sum_cost, used_num;", "predicted_diffs": [" - -24,7 +24,7 @@\n   }\n   int limit = 0;\n   priority_queue<Info> Q;\n-  Info first_sum, second_sum;\n+  Info first_sum, second_sum;\n   for (int i = 0; i <= N; i++) {\n     for (int j = 0; j <= M; j++)\n       dp[i][j] = 0;\n@@ -52,9 +52,8 @@\n           Q.push(Info(food[i], cost + 1));\n       }\n     }\n-    Info first_sum = 0;\n-    for (int i = 0; i <= M; i++) {\n-      first_sum += first_sum[i];\n-    }\n+    Info first_sum = 0;\n+    for (int i = 0; i <= M; i++) {\n+      first_sum += first_sum[i];\n     }\n     printf(\"%d\\n\", Dp[N][0]);\n   }"], "optimized_codes": ["#include <algorithm>\n#include <cfloat>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <stdio.h>\n#include <string>\n#include <vector>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\nstruct Info {\n  bool operator<(const struct Info &arg) const {\n    return sum_cost < arg.sum_cost;\n  };\n  int array[16];\n  int state, sum_cost, used_num;\n};\nint N, M;\nint POW[17];\nint dp[65536];\nint futon[16], demand[101];\nvoid func() {\n  futon[0] = 0;\n  for (int i = 1; i <= N; i++)\n    scanf(\"%d\", &futon[i]);\n  demand[0] = 0;\n  for (int i = 1; i <= M; i++)\n    scanf(\"%d\", &demand[i]);\n  sort(demand, demand + (M + 1));\n  N++;\n  for (int i = 0; i < POW[N]; i++)\n    dp[i] = BIG_NUM;\n  Info first;\n  first.state = 0;\n  first.used_num = 0;\n  first.sum_cost = 0;\n  priority_queue<Info> Q;\n  Q.push(first);\n  int tmp_sum, next_state;\n  while (!Q.empty()) {\n    if (Q.top().used_num == N) {\n      Q.pop();\n    } else if (Q.top().sum_cost > dp[Q.top().state]) {\n      Q.pop();\n          Q.push(Info(food[i], cost + 1));\n      }\n    }\n    Info first_sum = 0;\n    for (int i = 0; i <= M; i++) {\n      first_sum += first_sum[i];\n    }\n    printf(\"%d\\n\", Dp[N][0]);\n  }\n            next_info.array[Q.top().used_num] +=\n                next_info.array[Q.top().used_num - 1];\n          }\n          int index = 0;\n          tmp_sum = 0;\n          for (int i = 1; i <= M; i++) {\n            while (index < Q.top().used_num &&\n                   abs(demand[i] - next_info.array[index]) >\n                       abs(demand[i] - next_info.array[index + 1]))\n              index++;\n            tmp_sum += abs(demand[i] - next_info.array[index]);\n          }\n          next_state = Q.top().state + POW[loop];\n          if (dp[next_state] > tmp_sum) {\n            dp[next_state] = tmp_sum;\n            next_info.state = next_state;\n            next_info.sum_cost = tmp_sum;\n            next_info.used_num = Q.top().used_num + 1;\n            Q.push(next_info);\n          }\n        }\n      }\n      Q.pop();\n    }\n  }\n  printf(\"%d\\n\", dp[POW[N] - 1]);\n}\nint main() {\n  for (int i = 0; i < 17; i++)\n    POW[i] = pow(2, i);\n  while (true) {\n    scanf(\"%d %d\", &N, &M);\n    if (N == 0 && M == 0)\n      break;\n    func();\n  }\n  return 0;\n}"]}
{"problem_id": "p02269", "original": "#include <stdio.h>\r\n#include <string.h>\r\n#define M 1000007\r\n#define NIL (-1)\r\n#define L 14\r\nchar H[M][L];\r\nint getChar(char ch) {\r\n  if (ch == 'A')\r\n    return 1;\r\n  else if (ch == 'C')\r\n    return 2;\r\n  else if (ch == 'G')\r\n    return 3;\r\n  else if (ch == 'T')\r\n    return 4;\r\n  return -1;\r\n}\r\nlong long getKey(char str[]) {\r\n  long long sum = 0, p = 1, i;\r\n  for (i = 0; i < strlen(str); i++) {\r\n    sum += p * (getChar(str[i]));\r\n    p *= 5;\r\n  }\r\n  return sum;\r\n}\r\nint h1(int key) { return key % M; }\r\nint h2(int key) { return key % L; }\r\nint find(char str[]) {\r\n  int key = (int)(getKey(str) & 0x7fffffff);\r\n  return (H[h1(key)][h2(key)] == '\\0' ? 0 : 1);\r\n}\r\nint insert(char str[]) {\r\n  int key = (int)(getKey(str) & 0x7fffffff);\r\n  H[h1(key)][h2(key)] = 't';\r\n  return 0;\r\n}\r\nint main() {\r\n  int i, n, h;\r\n  char str[L], com[9];\r\n  for (i = 0; i < M; i++)\r\n    H[i][0] = '\\0';\r\n  scanf(\"%d\", &n);\r\n  for (i = 0; i < n; i++) {\r\n    scanf(\"%s %s\", com, str);\r\n    if (com[0] == 'i') {\r\n      insert(str);\r\n    } else {\r\n      if (find(str)) {\r\n        printf(\"yes\\n\");\r\n      } else {\r\n        printf(\"no\\n\");\r\n      }\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n", "diff": "@@ -1,6 +1,6 @@\n #include <stdio.h>\n #include <string.h>\n-#define M 1000007\n+#define M 876543\n #define NIL (-1)\n #define L 14\n char H[M][L];", "predicted_diffs": [" - -1,6 +1,6 @@\n #include <stdio.h>\n #include <string.h>\n-#define M 100000\n+#define M 1000001\n #define NIL (-1)\n #define L 14\n char H[M][L];"], "optimized_codes": ["#include <stdio.h>\n#include <string.h>\n#define M 1000007\n#define NIL (-1)\n#define L 14\nchar H[M][L];\nint getChar(char ch) {\n  if (ch == 'A')\n    return 1;\n  else if (ch == 'C')\n    return 2;\n  else if (ch == 'G')\n    return 3;\n  else if (ch == 'T')\n    return 4;\n  return -1;\n}\nlong long getKey(char str[]) {\n  long long sum = 0, p = 1, i;\n  for (i = 0; i < strlen(str); i++) {\n    sum += p * (getChar(str[i]));\n    p *= 5;\n  }\n  return sum;\n}\nint h1(int key) { return key % M; }\nint h2(int key) { return key % L; }\nint find(char str[]) {\n  int key = (int)(getKey(str) & 0x7fffffff);\n  return (H[h1(key)][h2(key)] == '\\0' ? 0 : 1);\n}\nint insert(char str[]) {\n  int key = (int)(getKey(str) & 0x7fffffff);\n  H[h1(key)][h2(key)] = 't';\n  return 0;\n}\nint main() {\n  int i, n, h;\n  char str[L], com[9];\n  for (i = 0; i < M; i++)\n    H[i][0] = '\\0';\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%s %s\", com, str);\n    if (com[0] == 'i') {\n      insert(str);\n    } else {\n      if (find(str)) {\n        printf(\"yes\\n\");\n      } else {\n        printf(\"no\\n\");\n      }\n    }\n  }\n  return 0;\n}"]}
{"problem_id": "p00525", "original": "#pragma comment(linker, \"/STACK:36777216\")\r\n#define LOCAL\r\n#include <algorithm>\r\n#include <cstdio>\r\n#include <iostream>\r\n#include <set>\r\n#include <vector>\r\nusing namespace std;\r\n#define REP(i, n) for (int i = 0; i < n; ++i)\r\n#define FOR(i, a, b) for (int i = a; i < b; ++i)\r\n#define DWN(i, b, a) for (int i = b - 1; i >= a; --i)\r\n#define REP_1(i, n) for (int i = 1; i <= n; ++i)\r\n#define FOR_1(i, a, b) for (int i = a; i <= b; ++i)\r\n#define DWN_1(i, b, a) for (int i = b; i >= a; --i)\r\n#define REP_C(i, n) for (int n____ = n, i = 0; i < n____; ++i)\r\n#define FOR_C(i, a, b) for (int b____ = b, i = a; i < b____; ++i)\r\n#define DWN_C(i, b, a) for (int a____ = a, i = b - 1; i >= a____; --i)\r\n#define REP_N(i, n) for (i = 0; i < n; ++i)\r\n#define FOR_N(i, a, b) for (i = a; i < b; ++i)\r\n#define DWN_N(i, b, a) for (i = b - 1; i >= a; --i)\r\n#define REP_1_C(i, n) for (int n____ = n, i = 1; i <= n____; ++i)\r\n#define FOR_1_C(i, a, b) for (int b____ = b, i = a; i <= b____; ++i)\r\n#define DWN_1_C(i, b, a) for (int a____ = a, i = b; i >= a____; --i)\r\n#define REP_1_N(i, n) for (i = 1; i <= n; ++i)\r\n#define FOR_1_N(i, a, b) for (i = a; i <= b; ++i)\r\n#define DWN_1_N(i, b, a) for (i = b; i >= a; --i)\r\n#define REP_C_N(i, n) for (int n____ = (i = 0, n); i < n____; ++i)\r\n#define FOR_C_N(i, a, b) for (int b____ = (i = 0, b); i < b____; ++i)\r\n#define DWN_C_N(i, b, a) for (int a____ = (i = b - 1, a); i >= a____; --i)\r\n#define REP_1_C_N(i, n) for (int n____ = (i = 1, n); i <= n____; ++i)\r\n#define FOR_1_C_N(i, a, b) for (int b____ = (i = a, b); i <= b____; ++i)\r\n#define DWN_1_C_N(i, b, a) for (int a____ = (i = b, a); i >= a____; --i)\r\n#define ECH(it, A)                                                             \\\r\n  for (__typeof((A).begin()) it = (A).begin(); it != (A).end(); ++it)\r\n#define rECH(it, A)                                                            \\\r\n  for (__typeof((A).rbegin()) it = (A).rbegin(); it != (A).rend(); ++it)\r\n#define REP_S(i, str) for (char *i = str; *i; ++i)\r\n#define REP_L(i, hd, suc) for (int i = hd; i; i = suc[i])\r\n#define REP_G(i, u) REP_L(i, hd[u], suc)\r\n#define REP_SS(x, s) for (int x = s; x; x = (x - 1) & s)\r\n#define DO(n) for (int ____n = n; ____n-- > 0;)\r\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\r\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\r\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\r\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\r\n#define REP_4(i, j, k, ii, n, m, l, nn)                                        \\\r\n  REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\r\n#define REP_4_1(i, j, k, ii, n, m, l, nn)                                      \\\r\n  REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\r\n#define ALL(A) A.begin(), A.end()\r\n#define LLA(A) A.rbegin(), A.rend()\r\n#define CPY(A, B) memcpy(A, B, sizeof(A))\r\n#define INS(A, P, B) A.insert(A.begin() + P, B)\r\n#define ERS(A, P) A.erase(A.begin() + P)\r\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\r\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\r\n#define CTN(T, x) (T.find(x) != T.end())\r\n#define SZ(A) int((A).size())\r\n#define PB push_back\r\n#define MP(A, B) make_pair(A, B)\r\n#define PTT pair<T, T>\r\n#define Ts *this\r\n#define rTs return Ts\r\n#define fi first\r\n#define se second\r\n#define re real()\r\n#define im imag()\r\n#define Rush for (int ____T = RD(); ____T--;)\r\n#define Display(A, n, m)                                                       \\\r\n  {                                                                            \\\r\n    REP(i, n) {                                                                \\\r\n      REP(j, m - 1) cout << A[i][j] << \" \";                                    \\\r\n      cout << A[i][m - 1] << endl;                                             \\\r\n    }                                                                          \\\r\n  }\r\n#define Display_1(A, n, m)                                                     \\\r\n  {                                                                            \\\r\n    REP_1(i, n) {                                                              \\\r\n      REP_1(j, m - 1) cout << A[i][j] << \" \";                                  \\\r\n      cout << A[i][m] << endl;                                                 \\\r\n    }                                                                          \\\r\n  }\r\ntypedef long long LL;\r\ntypedef double DB;\r\ntypedef unsigned uint;\r\ntypedef unsigned long long uLL;\r\ntypedef vector<int> VI;\r\ntemplate <class T> inline T &RD(T &);\r\ntemplate <class T> inline void OT(const T &);\r\ninline LL RD() {\r\n  LL x;\r\n  return RD(x);\r\n}\r\ninline DB &RF(DB &);\r\ninline DB RF() {\r\n  DB x;\r\n  return RF(x);\r\n}\r\ninline char *RS(char *s);\r\ninline char &RC(char &c);\r\ninline char RC();\r\ninline char &RC(char &c) {\r\n  scanf(\" %c\", &c);\r\n  return c;\r\n}\r\ninline char RC() {\r\n  char c;\r\n  return RC(c);\r\n}\r\ntemplate <class T> inline T &RDD(T &);\r\ninline LL RDD() {\r\n  LL x;\r\n  return RDD(x);\r\n}\r\ntemplate <class T0, class T1> inline T0 &RD(T0 &x0, T1 &x1) {\r\n  RD(x0), RD(x1);\r\n  return x0;\r\n}\r\ntemplate <class T0, class T1, class T2> inline T0 &RD(T0 &x0, T1 &x1, T2 &x2) {\r\n  RD(x0), RD(x1), RD(x2);\r\n  return x0;\r\n}\r\ntemplate <class T0, class T1, class T2, class T3>\r\ninline T0 &RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3) {\r\n  RD(x0), RD(x1), RD(x2), RD(x3);\r\n  return x0;\r\n}\r\ntemplate <class T0, class T1, class T2, class T3, class T4>\r\ninline T0 &RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4) {\r\n  RD(x0), RD(x1), RD(x2), RD(x3), RD(x4);\r\n  return x0;\r\n}\r\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\r\ninline T0 &RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5) {\r\n  RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5);\r\n  return x0;\r\n}\r\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\r\ninline T0 &RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6) {\r\n  RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6);\r\n  return x0;\r\n}\r\ntemplate <class T0, class T1> inline void OT(const T0 &x0, const T1 &x1) {\r\n  OT(x0), OT(x1);\r\n}\r\ntemplate <class T0, class T1, class T2>\r\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2) {\r\n  OT(x0), OT(x1), OT(x2);\r\n}\r\ntemplate <class T0, class T1, class T2, class T3>\r\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3) {\r\n  OT(x0), OT(x1), OT(x2), OT(x3);\r\n}\r\ntemplate <class T0, class T1, class T2, class T3, class T4>\r\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3,\r\n               const T4 &x4) {\r\n  OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);\r\n}\r\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\r\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3,\r\n               const T4 &x4, const T5 &x5) {\r\n  OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);\r\n}\r\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\r\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3,\r\n               const T4 &x4, const T5 &x5, const T6 &x6) {\r\n  OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);\r\n}\r\ninline char &RC(char &a, char &b) {\r\n  RC(a), RC(b);\r\n  return a;\r\n}\r\ninline char &RC(char &a, char &b, char &c) {\r\n  RC(a), RC(b), RC(c);\r\n  return a;\r\n}\r\ninline char &RC(char &a, char &b, char &c, char &d) {\r\n  RC(a), RC(b), RC(c), RC(d);\r\n  return a;\r\n}\r\ninline char &RC(char &a, char &b, char &c, char &d, char &e) {\r\n  RC(a), RC(b), RC(c), RC(d), RC(e);\r\n  return a;\r\n}\r\ninline char &RC(char &a, char &b, char &c, char &d, char &e, char &f) {\r\n  RC(a), RC(b), RC(c), RC(d), RC(e), RC(f);\r\n  return a;\r\n}\r\ninline char &RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g) {\r\n  RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g);\r\n  return a;\r\n}\r\ninline DB &RF(DB &a, DB &b) {\r\n  RF(a), RF(b);\r\n  return a;\r\n}\r\ninline DB &RF(DB &a, DB &b, DB &c) {\r\n  RF(a), RF(b), RF(c);\r\n  return a;\r\n}\r\ninline DB &RF(DB &a, DB &b, DB &c, DB &d) {\r\n  RF(a), RF(b), RF(c), RF(d);\r\n  return a;\r\n}\r\ninline DB &RF(DB &a, DB &b, DB &c, DB &d, DB &e) {\r\n  RF(a), RF(b), RF(c), RF(d), RF(e);\r\n  return a;\r\n}\r\ninline DB &RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f) {\r\n  RF(a), RF(b), RF(c), RF(d), RF(e), RF(f);\r\n  return a;\r\n}\r\ninline DB &RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g) {\r\n  RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g);\r\n  return a;\r\n}\r\ninline void RS(char *s1, char *s2) { RS(s1), RS(s2); }\r\ninline void RS(char *s1, char *s2, char *s3) { RS(s1), RS(s2), RS(s3); }\r\ntemplate <class T0, class T1> inline T0 &RDD(T0 &a, T1 &b) {\r\n  RDD(a), RDD(b);\r\n  return a;\r\n}\r\ntemplate <class T0, class T1, class T2> inline T1 &RDD(T0 &a, T1 &b, T2 &c) {\r\n  RDD(a), RDD(b), RDD(c);\r\n  return a;\r\n}\r\ntemplate <class T> inline void RST(T &A) { memset(A, 0, sizeof(A)); }\r\ntemplate <class T> inline void FLC(T &A, int x) { memset(A, x, sizeof(A)); }\r\ntemplate <class T> inline void CLR(T &A) { A.clear(); }\r\ntemplate <class T0, class T1> inline void RST(T0 &A0, T1 &A1) {\r\n  RST(A0), RST(A1);\r\n}\r\ntemplate <class T0, class T1, class T2>\r\ninline void RST(T0 &A0, T1 &A1, T2 &A2) {\r\n  RST(A0), RST(A1), RST(A2);\r\n}\r\ntemplate <class T0, class T1, class T2, class T3>\r\ninline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3) {\r\n  RST(A0), RST(A1), RST(A2), RST(A3);\r\n}\r\ntemplate <class T0, class T1, class T2, class T3, class T4>\r\ninline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4) {\r\n  RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);\r\n}\r\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\r\ninline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5) {\r\n  RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);\r\n}\r\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\r\ninline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6) {\r\n  RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);\r\n}\r\ntemplate <class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x) {\r\n  FLC(A0, x), FLC(A1, x);\r\n}\r\ntemplate <class T0, class T1, class T2>\r\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, int x) {\r\n  FLC(A0, x), FLC(A1, x), FLC(A2, x);\r\n}\r\ntemplate <class T0, class T1, class T2, class T3>\r\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x) {\r\n  FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);\r\n}\r\ntemplate <class T0, class T1, class T2, class T3, class T4>\r\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x) {\r\n  FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);\r\n}\r\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\r\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x) {\r\n  FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);\r\n}\r\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\r\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x) {\r\n  FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x),\r\n      FLC(A6, x);\r\n}\r\ntemplate <class T0, class T1> inline void CLR(T0 &A0, T1 &A1) {\r\n  CLR(A0), CLR(A1);\r\n}\r\ntemplate <class T0, class T1, class T2>\r\ninline void CLR(T0 &A0, T1 &A1, T2 &A2) {\r\n  CLR(A0), CLR(A1), CLR(A2);\r\n}\r\ntemplate <class T0, class T1, class T2, class T3>\r\ninline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3) {\r\n  CLR(A0), CLR(A1), CLR(A2), CLR(A3);\r\n}\r\ntemplate <class T0, class T1, class T2, class T3, class T4>\r\ninline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4) {\r\n  CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);\r\n}\r\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\r\ninline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5) {\r\n  CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);\r\n}\r\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\r\ninline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6) {\r\n  CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);\r\n}\r\ntemplate <class T> inline void CLR(T &A, int n) { REP(i, n) CLR(A[i]); }\r\ntemplate <class T> inline bool EPT(T &a) { return a.empty(); }\r\ntemplate <class T> inline T &SRT(T &A) {\r\n  sort(ALL(A));\r\n  return A;\r\n}\r\ntemplate <class T, class C> inline T &SRT(T &A, C B) {\r\n  sort(ALL(A), B);\r\n  return A;\r\n}\r\ntemplate <class T> inline T &RVS(T &A) {\r\n  reverse(ALL(A));\r\n  return A;\r\n}\r\ntemplate <class T> inline T &UNQQ(T &A) {\r\n  A.resize(unique(ALL(A)) - A.begin());\r\n  return A;\r\n}\r\ntemplate <class T> inline T &UNQ(T &A) {\r\n  SRT(A);\r\n  return UNQQ(A);\r\n}\r\nconst int MOD = int(1e9) + 7;\r\nconst int INF = 0x3f3f3f3f;\r\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\r\nconst DB EPS = 1e-9;\r\nconst DB OO = 1e20;\r\nconst int dx[] = {-1, 0, 1, 0};\r\nconst int dy[] = {0, 1, 0, -1};\r\ntemplate <class T> inline bool checkMin(T &a, const T b) {\r\n  return b < a ? a = b, 1 : 0;\r\n}\r\ntemplate <class T> inline bool checkMax(T &a, const T b) {\r\n  return a < b ? a = b, 1 : 0;\r\n}\r\ntemplate <class T, class C> inline bool checkUpd(T &a, const T b, C c) {\r\n  return c(b, a) ? a = b, 1 : 0;\r\n}\r\ntemplate <class T> inline T min(T a, T b, T c) { return min(min(a, b), c); }\r\ntemplate <class T> inline T max(T a, T b, T c) { return max(max(a, b), c); }\r\ntemplate <class T> inline T min(T a, T b, T c, T d) {\r\n  return min(min(a, b), min(c, d));\r\n}\r\ntemplate <class T> inline T max(T a, T b, T c, T d) {\r\n  return max(max(a, b), max(c, d));\r\n}\r\ntemplate <class T> inline T min(T a, T b, T c, T d, T e) {\r\n  return min(min(min(a, b), min(c, d)), e);\r\n}\r\ntemplate <class T> inline T max(T a, T b, T c, T d, T e) {\r\n  return max(max(max(a, b), max(c, d)), e);\r\n}\r\ntemplate <class T> inline T sqr(T a) { return a * a; }\r\ntemplate <class T> inline T cub(T a) { return a * a * a; }\r\ntemplate <class T> inline T ceil(T x, T y) { return (x - 1) / y + 1; }\r\ntemplate <class T> T abs(T x) { return x > 0 ? x : -x; }\r\ninline int sgn(DB x) { return x < -EPS ? -1 : x > EPS; }\r\ninline int sgn(DB x, DB y) { return sgn(x - y); }\r\n#define g (c = getchar())\r\n#define d isdigit(g)\r\n#define p x = x * 10 + c - '0'\r\n#define n x = x * 10 + '0' - c\r\n#define pp l /= 10, p\r\n#define nn l /= 10, n\r\ntemplate <class T> inline T &RD(T &x) {\r\n  char c;\r\n  while (!d)\r\n    ;\r\n  x = c - '0';\r\n  while (d)\r\n    p;\r\n  return x;\r\n}\r\ntemplate <class T> inline T &RDD(T &x) {\r\n  char c;\r\n  while (g, c != '-' && !isdigit(c))\r\n    ;\r\n  if (c == '-') {\r\n    x = '0' - g;\r\n    while (d)\r\n      n;\r\n  } else {\r\n    x = c - '0';\r\n    while (d)\r\n      p;\r\n  }\r\n  return x;\r\n}\r\ninline DB &RF(DB &x) {\r\n  char c;\r\n  while (g, c != '-' && c != '.' && !isdigit(c))\r\n    ;\r\n  if (c == '-')\r\n    if (g == '.') {\r\n      x = 0;\r\n      DB l = 1;\r\n      while (d)\r\n        nn;\r\n      x *= l;\r\n    } else {\r\n      x = '0' - c;\r\n      while (d)\r\n        n;\r\n      if (c == '.') {\r\n        DB l = 1;\r\n        while (d)\r\n          nn;\r\n        x *= l;\r\n      }\r\n    }\r\n  else if (c == '.') {\r\n    x = 0;\r\n    DB l = 1;\r\n    while (d)\r\n      pp;\r\n    x *= l;\r\n  } else {\r\n    x = c - '0';\r\n    while (d)\r\n      p;\r\n    if (c == '.') {\r\n      DB l = 1;\r\n      while (d)\r\n        pp;\r\n      x *= l;\r\n    }\r\n  }\r\n  return x;\r\n}\r\n#undef nn\r\n#undef pp\r\n#undef n\r\n#undef p\r\n#undef d\r\n#undef g\r\ninline char *RS(char *s) {\r\n  scanf(\"%s\", s);\r\n  return s;\r\n}\r\nLL last_ans;\r\nint Case;\r\ntemplate <class T> inline void OT(const T &x) { cout << x << endl; }\r\nconst int MAXN = 100020;\r\nvector<int> xs;\r\nnamespace ST {\r\nconst int NN = 8 * MAXN;\r\nbool T[NN];\r\nint a, b;\r\n#define lx (x << 1)\r\n#define rx (lx | 1)\r\n#define ml (l + r >> 1)\r\n#define mr (ml + 1)\r\n#define lc lx, l, ml\r\n#define rc rx, mr, r\r\n#define rt 1, 0, xs.size()\r\nvoid cov(int x) { T[x] = 1; }\r\nvoid rls(int x) {\r\n  if (T[x]) {\r\n    T[lx] = T[rx] = 1;\r\n    T[x] = 0;\r\n  }\r\n}\r\nbool Query(int x, int l, int r, int p) {\r\n  if (l == r) {\r\n    bool z = T[x];\r\n    T[x] = 0;\r\n    return z;\r\n  } else {\r\n    rls(x);\r\n    return p < mr ? Query(lc, p) : Query(rc, p);\r\n  }\r\n}\r\nbool Query(int p) { return Query(rt, p); }\r\nvoid Insert(int x, int l, int r) {\r\n  if (b < l || r < a)\r\n    return;\r\n  if (a <= l && r <= b) {\r\n    cov(x);\r\n  } else {\r\n    rls(x);\r\n    Insert(lc);\r\n    Insert(rc);\r\n  }\r\n}\r\nvoid Insert(int _a, int _b) {\r\n  a = _a, b = _b;\r\n  Insert(rt);\r\n}\r\nvoid Clear(int x, int l, int r, int p) {\r\n  if (l == r) {\r\n    T[x] = 0;\r\n  } else {\r\n    rls(x);\r\n    if (p < mr)\r\n      Clear(lc, p);\r\n    else\r\n      Clear(rc, p);\r\n  }\r\n}\r\n} // namespace ST\r\nstruct action {\r\n  int pos, act, left, right;\r\n  action(int p, int a, int l, int r) {\r\n    pos = p;\r\n    act = a;\r\n    left = l;\r\n    right = r;\r\n  }\r\n};\r\ninline bool operator<(const action &a, const action &b) {\r\n  return a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\r\n}\r\nint W, H, N;\r\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\r\nvector<int> uf;\r\nint target[MAXN * 2];\r\nint root(int p) { return (uf[p] == p) ? p : (uf[p] = root(uf[p])); }\r\nbool join(int p, int q) {\r\n  p = root(p);\r\n  q = root(q);\r\n  if (p == q)\r\n    return false;\r\n  uf[q] = p;\r\n  return true;\r\n}\r\nvoid adjust(int p) {\r\n  if (ST::Query(p)) {\r\n    int t = uf.size();\r\n    uf.push_back(t);\r\n    target[p] = t;\r\n  }\r\n}\r\ntemplate <class T> inline T low_bit(T x) { return x & -x; }\r\nnamespace BIT {\r\nconst int N = MAXN * 2;\r\nint C[N], n;\r\nvoid Add(int x, int d) {\r\n  for (; x <= n; x += low_bit(x))\r\n    C[x] += d;\r\n}\r\nint Sum(int x) {\r\n  int res = 0;\r\n  for (; x; x ^= low_bit(x))\r\n    res += C[x];\r\n  return res;\r\n}\r\nint Sum(int l, int r) { return Sum(r) - Sum(l - 1); }\r\n} // namespace BIT\r\nint main() {\r\n#ifndef ONLINE_JUDGE\r\n#endif\r\n  scanf(\"%d%d%d\", &W, &H, &N);\r\n  for (int i = 0; i < N; i++) {\r\n    scanf(\"%d%d%d%d\", x1 + i, y1 + i, x2 + i, y2 + i);\r\n    if (x1[i] > x2[i])\r\n      swap(x1[i], x2[i]);\r\n    if (y1[i] > y2[i])\r\n      swap(y1[i], y2[i]);\r\n  }\r\n  x1[N] = 0;\r\n  y1[N] = 0;\r\n  x2[N] = W;\r\n  y2[N] = 0;\r\n  x1[N + 1] = 0;\r\n  y1[N + 1] = 0;\r\n  x2[N + 1] = 0;\r\n  y2[N + 1] = H;\r\n  x1[N + 2] = W;\r\n  y1[N + 2] = 0;\r\n  x2[N + 2] = W;\r\n  y2[N + 2] = H;\r\n  x1[N + 3] = 0;\r\n  y1[N + 3] = H;\r\n  x2[N + 3] = W;\r\n  y2[N + 3] = H;\r\n  N += 4;\r\n  for (int i = 0; i < N; i++) {\r\n    xs.push_back(x1[i]);\r\n    xs.push_back(x2[i]);\r\n  }\r\n  xs.push_back(-1);\r\n  UNQ(xs);\r\n  BIT::n = xs.size();\r\n  for (int i = 0; i < N; i++) {\r\n    x1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\r\n    x2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\r\n  }\r\n  set<int> S;\r\n  S.insert(0);\r\n  target[0] = 0;\r\n  uf.push_back(0);\r\n  vector<action> A;\r\n  for (int i = 0; i < N; i++) {\r\n    if (x1[i] == x2[i]) {\r\n      A.push_back(action(y1[i], 0, x1[i], -1));\r\n      A.push_back(action(y2[i], 2, x1[i], -1));\r\n    } else {\r\n      A.push_back(action(y1[i], 1, x1[i], x2[i]));\r\n    }\r\n  }\r\n  sort(A.begin(), A.end());\r\n  long long ret = 0;\r\n  for (int i = 0; i < A.size(); i++) {\r\n    action V = A[i];\r\n    if (V.act == 0) {\r\n      int lf = *--S.lower_bound(V.left);\r\n      adjust(lf);\r\n      adjust(V.left);\r\n      join(target[V.left], target[lf]);\r\n      S.insert(V.left);\r\n      BIT::Add(V.left, 1);\r\n    } else if (V.act == 1) {\r\n      int ll = *S.lower_bound(V.left);\r\n      int rr = *--S.upper_bound(V.right);\r\n      if (rr <= ll)\r\n        continue;\r\n      ret += BIT::Sum(ll, rr) - 1;\r\n      ST::Insert(ll, rr - 1);\r\n    } else if (V.act == 2) {\r\n      int lf = *--S.lower_bound(V.left);\r\n      adjust(lf);\r\n      adjust(V.left);\r\n      int rett = ret;\r\n      if (join(target[lf], target[V.left]))\r\n        --ret;\r\n      S.erase(V.left);\r\n      BIT::Add(V.left, -1);\r\n    }\r\n  }\r\n  printf(\"%lld\\n\", ret);\r\n  return 0;\r\n}\r\n", "diff": "@@ -546,8 +546,6 @@\n int Sum(int l, int r) { return Sum(r) - Sum(l - 1); }\n } // namespace BIT\n int main() {\n-#ifndef ONLINE_JUDGE\n-#endif\n   scanf(\"%d%d%d\", &W, &H, &N);\n   for (int i = 0; i < N; i++) {\n     scanf(\"%d%d%d%d\", x1 + i, y1 + i, x2 + i, y2 + i);\n@@ -611,9 +609,9 @@\n     } else if (V.act == 1) {\n       int ll = *S.lower_bound(V.left);\n       int rr = *--S.upper_bound(V.right);\n-      if (rr <= ll)\n+      if (rr < ll)\n         continue;\n-      ret += BIT::Sum(ll, rr) - 1;\n+      ret += BIT::Sum(ll, rr - 1);\n       ST::Insert(ll, rr - 1);\n     } else if (V.act == 2) {\n       int lf = *--S.lower_bound(V.left);", "predicted_diffs": [" - -500,7 +500,6 @@\n }\n int W, H, N;\n int x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\n-int target[MAXN * 2];\n namespace DSU {\n VI P;\n inline int Find(int x) { return P[x] == x ? x : P[x] = Find(P[x]); }\n@@ -516,7 +515,7 @@\n   if (ST::Query(p)) {\n     int n = DSU::P.size();\n     DSU::P.PB(n);\n-    target[p] = n;\n+    DSU::P[p] = n;\n   }\n }\n template <class T> inline T low_bit(T x) { return x & -x; }\n@@ -576,7 +575,6 @@\n   }\n   set<int> S;\n   S.insert(0);\n-  target[0] = 0;\n   DSU::P.PB(0);\n   vector<action> A;\n   for (int i = 0; i < N; i++) {\n@@ -588,6 +586,7 @@\n     }\n   }\n   sort(A.begin(), A.end());\n+  REP(i, xs.size()) { DSU::P.PB(0); }\n   long long ret = 0;\n   for (int i = 0; i < A.size(); i++) {\n     action V = A[i];\n@@ -595,7 +594,7 @@\n       int lf = *--S.lower_bound(V.left);\n       adjust(lf);\n       adjust(V.left);\n-      DSU::Union(target[V.left], target[lf]);\n+      DSU::Union(V.left, lf);\n       S.insert(V.left);\n       BIT::Add(V.left"], "optimized_codes": ["#pragma comment(linker, \"/STACK:36777216\")\n#define LOCAL\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <set>\n#include <vector>\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < n; ++i)\n#define FOR(i, a, b) for (int i = a; i < b; ++i)\n#define DWN(i, b, a) for (int i = b - 1; i >= a; --i)\n#define REP_1(i, n) for (int i = 1; i <= n; ++i)\n#define FOR_1(i, a, b) for (int i = a; i <= b; ++i)\n#define DWN_1(i, b, a) for (int i = b; i >= a; --i)\n#define REP_C(i, n) for (int n____ = n, i = 0; i < n____; ++i)\n#define FOR_C(i, a, b) for (int b____ = b, i = a; i < b____; ++i)\n#define DWN_C(i, b, a) for (int a____ = a, i = b - 1; i >= a____; --i)\n#define REP_N(i, n) for (i = 0; i < n; ++i)\n#define FOR_N(i, a, b) for (i = a; i < b; ++i)\n#define DWN_N(i, b, a) for (i = b - 1; i >= a; --i)\n#define REP_1_C(i, n) for (int n____ = n, i = 1; i <= n____; ++i)\n#define FOR_1_C(i, a, b) for (int b____ = b, i = a; i <= b____; ++i)\n#define DWN_1_C(i, b, a) for (int a____ = a, i = b; i >= a____; --i)\n#define REP_1_N(i, n) for (i = 1; i <= n; ++i)\n#define FOR_1_N(i, a, b) for (i = a; i <= b; ++i)\n#define DWN_1_N(i, b, a) for (i = b; i >= a; --i)\n#define REP_C_N(i, n) for (int n____ = (i = 0, n); i < n____; ++i)\n#define FOR_C_N(i, a, b) for (int b____ = (i = 0, b); i < b____; ++i)\n#define DWN_C_N(i, b, a) for (int a____ = (i = b - 1, a); i >= a____; --i)\n#define REP_1_C_N(i, n) for (int n____ = (i = 1, n); i <= n____; ++i)\n#define FOR_1_C_N(i, a, b) for (int b____ = (i = a, b); i <= b____; ++i)\n#define DWN_1_C_N(i, b, a) for (int a____ = (i = b, a); i >= a____; --i)\n#define ECH(it, A)                                                             \\\n  for (__typeof((A).begin()) it = (A).begin(); it != (A).end(); ++it)\n#define rECH(it, A)                                                            \\\n  for (__typeof((A).rbegin()) it = (A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char *i = str; *i; ++i)\n#define REP_L(i, hd, suc) for (int i = hd; i; i = suc[i])\n#define REP_G(i, u) REP_L(i, hd[u], suc)\n#define REP_SS(x, s) for (int x = s; x; x = (x - 1) & s)\n#define DO(n) for (int ____n = n; ____n-- > 0;)\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn)                                        \\\n  REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn)                                      \\\n  REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n#define Rush for (int ____T = RD(); ____T--;)\n#define Display(A, n, m)                                                       \\\n  {                                                                            \\\n    REP(i, n) {                                                                \\\n      REP(j, m - 1) cout << A[i][j] << \" \";                                    \\\n      cout << A[i][m - 1] << endl;                                             \\\n    }                                                                          \\\n  }\n#define Display_1(A, n, m)                                                     \\\n  {                                                                            \\\n    REP_1(i, n) {                                                              \\\n      REP_1(j, m - 1) cout << A[i][j] << \" \";                                  \\\n      cout << A[i][m] << endl;                                                 \\\n    }                                                                          \\\n  }\ntypedef long long LL;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\ntypedef vector<int> VI;\ntemplate <class T> inline T &RD(T &);\ntemplate <class T> inline void OT(const T &);\ninline LL RD() {\n  LL x;\n  return RD(x);\n}\ninline DB &RF(DB &);\ninline DB RF() {\n  DB x;\n  return RF(x);\n}\ninline char *RS(char *s);\ninline char &RC(char &c);\ninline char RC();\ninline char &RC(char &c) {\n  scanf(\" %c\", &c);\n  return c;\n}\ninline char RC() {\n  char c;\n  return RC(c);\n}\ntemplate <class T> inline T &RDD(T &);\ninline LL RDD() {\n  LL x;\n  return RDD(x);\n}\ntemplate <class T0, class T1> inline T0 &RD(T0 &x0, T1 &x1) {\n  RD(x0), RD(x1);\n  return x0;\n}\ntemplate <class T0, class T1, class T2> inline T0 &RD(T0 &x0, T1 &x1, T2 &x2) {\n  RD(x0), RD(x1), RD(x2);\n  return x0;\n}\ntemplate <class T0, class T1, class T2, class T3>\ninline T0 &RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3) {\n  RD(x0), RD(x1), RD(x2), RD(x3);\n  return x0;\n}\ntemplate <class T0, class T1, class T2, class T3, class T4>\ninline T0 &RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4) {\n  RD(x0), RD(x1), RD(x2), RD(x3), RD(x4);\n  return x0;\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\ninline T0 &RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5) {\n  RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5);\n  return x0;\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\ninline T0 &RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6) {\n  RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6);\n  return x0;\n}\ntemplate <class T0, class T1> inline void OT(const T0 &x0, const T1 &x1) {\n  OT(x0), OT(x1);\n}\ntemplate <class T0, class T1, class T2>\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2) {\n  OT(x0), OT(x1), OT(x2);\n}\ntemplate <class T0, class T1, class T2, class T3>\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3) {\n  OT(x0), OT(x1), OT(x2), OT(x3);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4>\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3,\n               const T4 &x4) {\n  OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3,\n               const T4 &x4, const T5 &x5) {\n  OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\ninline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3,\n               const T4 &x4, const T5 &x5, const T6 &x6) {\n  OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);\n}\ninline char &RC(char &a, char &b) {\n  RC(a), RC(b);\n  return a;\n}\ninline char &RC(char &a, char &b, char &c) {\n  RC(a), RC(b), RC(c);\n  return a;\n}\ninline char &RC(char &a, char &b, char &c, char &d) {\n  RC(a), RC(b), RC(c), RC(d);\n  return a;\n}\ninline char &RC(char &a, char &b, char &c, char &d, char &e) {\n  RC(a), RC(b), RC(c), RC(d), RC(e);\n  return a;\n}\ninline char &RC(char &a, char &b, char &c, char &d, char &e, char &f) {\n  RC(a), RC(b), RC(c), RC(d), RC(e), RC(f);\n  return a;\n}\ninline char &RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g) {\n  RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g);\n  return a;\n}\ninline DB &RF(DB &a, DB &b) {\n  RF(a), RF(b);\n  return a;\n}\ninline DB &RF(DB &a, DB &b, DB &c) {\n  RF(a), RF(b), RF(c);\n  return a;\n}\ninline DB &RF(DB &a, DB &b, DB &c, DB &d) {\n  RF(a), RF(b), RF(c), RF(d);\n  return a;\n}\ninline DB &RF(DB &a, DB &b, DB &c, DB &d, DB &e) {\n  RF(a), RF(b), RF(c), RF(d), RF(e);\n  return a;\n}\ninline DB &RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f) {\n  RF(a), RF(b), RF(c), RF(d), RF(e), RF(f);\n  return a;\n}\ninline DB &RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g) {\n  RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g);\n  return a;\n}\ninline void RS(char *s1, char *s2) { RS(s1), RS(s2); }\ninline void RS(char *s1, char *s2, char *s3) { RS(s1), RS(s2), RS(s3); }\ntemplate <class T0, class T1> inline T0 &RDD(T0 &a, T1 &b) {\n  RDD(a), RDD(b);\n  return a;\n}\ntemplate <class T0, class T1, class T2> inline T1 &RDD(T0 &a, T1 &b, T2 &c) {\n  RDD(a), RDD(b), RDD(c);\n  return a;\n}\ntemplate <class T> inline void RST(T &A) { memset(A, 0, sizeof(A)); }\ntemplate <class T> inline void FLC(T &A, int x) { memset(A, x, sizeof(A)); }\ntemplate <class T> inline void CLR(T &A) { A.clear(); }\ntemplate <class T0, class T1> inline void RST(T0 &A0, T1 &A1) {\n  RST(A0), RST(A1);\n}\ntemplate <class T0, class T1, class T2>\ninline void RST(T0 &A0, T1 &A1, T2 &A2) {\n  RST(A0), RST(A1), RST(A2);\n}\ntemplate <class T0, class T1, class T2, class T3>\ninline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3) {\n  RST(A0), RST(A1), RST(A2), RST(A3);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4>\ninline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4) {\n  RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\ninline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5) {\n  RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\ninline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6) {\n  RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);\n}\ntemplate <class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x) {\n  FLC(A0, x), FLC(A1, x);\n}\ntemplate <class T0, class T1, class T2>\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, int x) {\n  FLC(A0, x), FLC(A1, x), FLC(A2, x);\n}\ntemplate <class T0, class T1, class T2, class T3>\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x) {\n  FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4>\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x) {\n  FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x) {\n  FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\ninline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x) {\n  FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x),\n      FLC(A6, x);\n}\ntemplate <class T0, class T1> inline void CLR(T0 &A0, T1 &A1) {\n  CLR(A0), CLR(A1);\n}\ntemplate <class T0, class T1, class T2>\ninline void CLR(T0 &A0, T1 &A1, T2 &A2) {\n  CLR(A0), CLR(A1), CLR(A2);\n}\ntemplate <class T0, class T1, class T2, class T3>\ninline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3) {\n  CLR(A0), CLR(A1), CLR(A2), CLR(A3);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4>\ninline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4) {\n  CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5>\ninline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5) {\n  CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4, class T5, class T6>\ninline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6) {\n  CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);\n}\ntemplate <class T> inline void CLR(T &A, int n) { REP(i, n) CLR(A[i]); }\ntemplate <class T> inline bool EPT(T &a) { return a.empty(); }\ntemplate <class T> inline T &SRT(T &A) {\n  sort(ALL(A));\n  return A;\n}\ntemplate <class T, class C> inline T &SRT(T &A, C B) {\n  sort(ALL(A), B);\n  return A;\n}\ntemplate <class T> inline T &RVS(T &A) {\n  reverse(ALL(A));\n  return A;\n}\ntemplate <class T> inline T &UNQQ(T &A) {\n  A.resize(unique(ALL(A)) - A.begin());\n  return A;\n}\ntemplate <class T> inline T &UNQ(T &A) {\n  SRT(A);\n  return UNQQ(A);\n}\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\ntemplate <class T> inline bool checkMin(T &a, const T b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <class T> inline bool checkMax(T &a, const T b) {\n  return a < b ? a = b, 1 : 0;\n}\ntemplate <class T, class C> inline bool checkUpd(T &a, const T b, C c) {\n  return c(b, a) ? a = b, 1 : 0;\n}\ntemplate <class T> inline T min(T a, T b, T c) { return min(min(a, b), c); }\ntemplate <class T> inline T max(T a, T b, T c) { return max(max(a, b), c); }\ntemplate <class T> inline T min(T a, T b, T c, T d) {\n  return min(min(a, b), min(c, d));\n}\ntemplate <class T> inline T max(T a, T b, T c, T d) {\n  return max(max(a, b), max(c, d));\n}\ntemplate <class T> inline T min(T a, T b, T c, T d, T e) {\n  return min(min(min(a, b), min(c, d)), e);\n}\ntemplate <class T> inline T max(T a, T b, T c, T d, T e) {\n  return max(max(max(a, b), max(c, d)), e);\n}\ntemplate <class T> inline T sqr(T a) { return a * a; }\ntemplate <class T> inline T cub(T a) { return a * a * a; }\ntemplate <class T> inline T ceil(T x, T y) { return (x - 1) / y + 1; }\ntemplate <class T> T abs(T x) { return x > 0 ? x : -x; }\ninline int sgn(DB x) { return x < -EPS ? -1 : x > EPS; }\ninline int sgn(DB x, DB y) { return sgn(x - y); }\n#define g (c = getchar())\n#define d isdigit(g)\n#define p x = x * 10 + c - '0'\n#define n x = x * 10 + '0' - c\n#define pp l /= 10, p\n#define nn l /= 10, n\ntemplate <class T> inline T &RD(T &x) {\n  char c;\n  while (!d)\n    ;\n  x = c - '0';\n  while (d)\n    p;\n  return x;\n}\ntemplate <class T> inline T &RDD(T &x) {\n  char c;\n  while (g, c != '-' && !isdigit(c))\n    ;\n  if (c == '-') {\n    x = '0' - g;\n    while (d)\n      n;\n  } else {\n    x = c - '0';\n    while (d)\n      p;\n  }\n  return x;\n}\ninline DB &RF(DB &x) {\n  char c;\n  while (g, c != '-' && c != '.' && !isdigit(c))\n    ;\n  if (c == '-')\n    if (g == '.') {\n      x = 0;\n      DB l = 1;\n      while (d)\n        nn;\n      x *= l;\n    } else {\n      x = '0' - c;\n      while (d)\n        n;\n      if (c == '.') {\n        DB l = 1;\n        while (d)\n          nn;\n        x *= l;\n      }\n    }\n  else if (c == '.') {\n    x = 0;\n    DB l = 1;\n    while (d)\n      pp;\n    x *= l;\n  } else {\n    x = c - '0';\n    while (d)\n      p;\n    if (c == '.') {\n      DB l = 1;\n      while (d)\n        pp;\n      x *= l;\n    }\n  }\n  return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char *RS(char *s) {\n  scanf(\"%s\", s);\n  return s;\n}\nLL last_ans;\nint Case;\ntemplate <class T> inline void OT(const T &x) { cout << x << endl; }\nconst int MAXN = 100020;\nvector<int> xs;\nnamespace ST {\nconst int NN = 8 * MAXN;\nbool T[NN];\nint a, b;\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 0, xs.size()\nvoid cov(int x) { T[x] = 1; }\nvoid rls(int x) {\n  if (T[x]) {\n    T[lx] = T[rx] = 1;\n    T[x] = 0;\n  }\n}\nbool Query(int x, int l, int r, int p) {\n  if (l == r) {\n    bool z = T[x];\n    T[x] = 0;\n    return z;\n  } else {\n    rls(x);\n    return p < mr ? Query(lc, p) : Query(rc, p);\n  }\n}\nbool Query(int p) { return Query(rt, p); }\nvoid Insert(int x, int l, int r) {\n  if (b < l || r < a)\n    return;\n  if (a <= l && r <= b) {\n    cov(x);\n  } else {\n    rls(x);\n    Insert(lc);\n    Insert(rc);\n  }\n}\nvoid Insert(int _a, int _b) {\n  a = _a, b = _b;\n  Insert(rt);\n}\nvoid Clear(int x, int l, int r, int p) {\n  if (l == r) {\n    T[x] = 0;\n  } else {\n    rls(x);\n    if (p < mr)\n      Clear(lc, p);\n    else\n      Clear(rc, p);\n  }\n}\n} // namespace ST\nstruct action {\n  int pos, act, left, right;\n  action(int p, int a, int l, int r) {\n    pos = p;\n    act = a;\n    left = l;\n    right = r;\n  }\n};\ninline bool operator<(const action &a, const action &b) {\n  return a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nint target[MAXN * 2];\n  if (ST::Query(p)) {\n    int n = DSU::P.size();\n    DSU::P.PB(n);\n    DSU::P[p] = n;\n  }\n}\ntemplate <class T> inline T low_bit(T x) { return x & -x; }\n  return true;\n}\nvoid adjust(int p) {\n  if (ST::Query(p)) {\n    int t = uf.size();\n    uf.push_back(t);\n    target[p] = t;\n  }\n}\ntemplate <class T> inline T low_bit(T x) { return x & -x; }\nnamespace BIT {\nconst int N = MAXN * 2;\nint C[N], n;\nvoid Add(int x, int d) {\n  for (; x <= n; x += low_bit(x))\n    C[x] += d;\n}\nint Sum(int x) {\n  int res = 0;\n  for (; x; x ^= low_bit(x))\n    res += C[x];\n  return res;\n}\nint Sum(int l, int r) { return Sum(r) - Sum(l - 1); }\n} // namespace BIT\nint main() {\n#ifndef ONLINE_JUDGE\n#endif\n  scanf(\"%d%d%d\", &W, &H, &N);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d%d%d%d\", x1 + i, y1 + i, x2 + i, y2 + i);\n    if (x1[i] > x2[i])\n      swap(x1[i], x2[i]);\n    if (y1[i] > y2[i])\n      swap(y1[i], y2[i]);\n  }\n  x1[N] = 0;\n  y1[N] = 0;\n  x2[N] = W;\n  y2[N] = 0;\n  x1[N + 1] = 0;\n  y1[N + 1] = 0;\n  x2[N + 1] = 0;\n  y2[N + 1] = H;\n  x1[N + 2] = W;\n  y1[N + 2] = 0;\n  x2[N + 2] = W;\n  y2[N + 2] = H;\n  x1[N + 3] = 0;\n  y1[N + 3] = H;\n  x2[N + 3] = W;\n  y2[N + 3] = H;\n  N += 4;\n  }\n  set<int> S;\n  S.insert(0);\n  DSU::P.PB(0);\n  vector<action> A;\n  for (int i = 0; i < N; i++) {\n  for (int i = 0; i < N; i++) {\n    x1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n    x2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n  }\n  set<int> S;\n    }\n  }\n  sort(A.begin(), A.end());\n  REP(i, xs.size()) { DSU::P.PB(0); }\n  long long ret = 0;\n  for (int i = 0; i < A.size(); i++) {\n    action V = A[i];\n      A.push_back(action(y1[i], 0, x1[i], -1));\n      int lf = *--S.lower_bound(V.left);\n      adjust(lf);\n      adjust(V.left);\n      DSU::Union(V.left, lf);\n      S.insert(V.left);\n      BIT::Add(V.left\n  for (int i = 0; i < A.size(); i++) {\n    action V = A[i];\n    if (V.act == 0) {\n      int lf = *--S.lower_bound(V.left);\n      adjust(lf);\n      adjust(V.left);\n      join(target[V.left], target[lf]);\n      S.insert(V.left);\n      BIT::Add(V.left, 1);\n    } else if (V.act == 1) {\n      int ll = *S.lower_bound(V.left);\n      int rr = *--S.upper_bound(V.right);\n      if (rr <= ll)\n        continue;\n      ret += BIT::Sum(ll, rr) - 1;\n      ST::Insert(ll, rr - 1);\n    } else if (V.act == 2) {\n      int lf = *--S.lower_bound(V.left);\n      adjust(lf);\n      adjust(V.left);\n      int rett = ret;\n      if (join(target[lf], target[V.left]))\n        --ret;\n      S.erase(V.left);\n      BIT::Add(V.left, -1);\n    }\n  }\n  printf(\"%lld\\n\", ret);\n  return 0;\n}"]}
{"problem_id": "p00850", "original": "#include <iostream>\r\nusing namespace std;\r\n#define MAX 1000\r\n#define LIMIT 13\r\nbool state[MAX + 1];\r\nint ans[MAX + 1];\r\nint target;\r\nvoid dfs(int depth, int pre, int maxv) {\r\n  if (pre == target) {\r\n    ans[target] = min(ans[target], depth);\r\n    return;\r\n  }\r\n  if (depth >= ans[target])\r\n    return;\r\n  int next, d = 0, p = maxv;\r\n  while (p < target) {\r\n    d++;\r\n    p *= 2;\r\n  }\r\n  if (depth + d >= ans[target])\r\n    return;\r\n  for (int i = 1; i <= maxv; i++) {\r\n    if (!state[i])\r\n      continue;\r\n    next = pre + i;\r\n    if (next <= MAX && !state[next]) {\r\n      state[next] = true;\r\n      dfs(depth + 1, next, max(maxv, next));\r\n      state[next] = false;\r\n    }\r\n    next = (pre > i) ? (pre - i) : (i - pre);\r\n    if (!state[next]) {\r\n      state[next] = true;\r\n      dfs(depth + 1, next, max(maxv, next));\r\n      state[next] = false;\r\n    }\r\n  }\r\n}\r\nmain() {\r\n  for (int i = 0; i <= MAX + 1; i++)\r\n    ans[i] = LIMIT;\r\n  while (cin >> target && target) {\r\n    for (int i = 0; i <= MAX + 1; i++)\r\n      state[i] = false;\r\n    state[1] = true;\r\n    dfs(0, 1, 1);\r\n    cout << ans[target] << endl;\r\n  }\r\n}\r\n", "diff": "@@ -3,8 +3,7 @@\n #define MAX 1000\n #define LIMIT 13\n bool state[MAX + 1];\n-int ans[MAX + 1];\n-int target;\n+int ans[MAX + 1], target;\n void dfs(int depth, int pre, int maxv) {\n   if (pre == target) {\n     ans[target] = min(ans[target], depth);", "predicted_diffs": [" - -2,7 +2,7 @@\n using namespace std;\n #define MAX 1000\n bool board[MAX + 1];\n-#define MAX 2\n+#define MAX 100\n int ans[MAX + 1];\n void dfs(int depth, int pre, int max) {\n   if (depth == target)"], "optimized_codes": ["#include <iostream>\nusing namespace std;\n#define MAX 1000\n#define LIMIT 13\nbool state[MAX + 1];\nint ans[MAX + 1];\nint target;\nvoid dfs(int depth, int pre, int maxv) {\n  if (pre == target) {\n    ans[target] = min(ans[target], depth);\n    return;\n  }\n  if (depth >= ans[target])\n    return;\n  int next, d = 0, p = maxv;\n  while (p < target) {\n    d++;\n    p *= 2;\n  }\n  if (depth + d >= ans[target])\n    return;\n  for (int i = 1; i <= maxv; i++) {\n    if (!state[i])\n      continue;\n    next = pre + i;\n    if (next <= MAX && !state[next]) {\n      state[next] = true;\n      dfs(depth + 1, next, max(maxv, next));\n      state[next] = false;\n    }\n    next = (pre > i) ? (pre - i) : (i - pre);\n    if (!state[next]) {\n      state[next] = true;\n      dfs(depth + 1, next, max(maxv, next));\n      state[next] = false;\n    }\n  }\n}\nmain() {\n  for (int i = 0; i <= MAX + 1; i++)\n    ans[i] = LIMIT;\n  while (cin >> target && target) {\n    for (int i = 0; i <= MAX + 1; i++)\n      state[i] = false;\n    state[1] = true;\n    dfs(0, 1, 1);\n    cout << ans[target] << endl;\n  }\n}"]}
{"problem_id": "p02269", "original": "#include <cmath>\r\n#include <iostream>\r\n#include <string>\r\n#include <vector>\r\nusing namespace std;\r\nint NumStr(string str) {\r\n  int n = str.size();\r\n  int sum = 0;\r\n  for (int i = 0; i < n; i++) {\r\n    if (str[i] == 'A')\r\n      sum += pow(4., i) * 1;\r\n    else if (str[i] == 'C')\r\n      sum += pow(4., i) * 2;\r\n    else if (str[i] == 'G')\r\n      sum += pow(4., i) * 3;\r\n    else if (str[i] == 'T')\r\n      sum += pow(4., i) * 4;\r\n  }\r\n  return sum;\r\n}\r\nvoid InsertFlag(vector<bool> &flag, string str) {\r\n  int num_str = NumStr(str);\r\n  flag[num_str] = true;\r\n}\r\nvoid FindFlag(vector<bool> &flag, string str) {\r\n  int num_str = NumStr(str);\r\n  if (flag[num_str] == true)\r\n    cout << \"yes\" << endl;\r\n  else if (flag[num_str] == false)\r\n    cout << \"no\" << endl;\r\n}\r\nint main() {\r\n  cin.tie(0);\r\n  ios_base::sync_with_stdio(false);\r\n  int n;\r\n  cin >> n;\r\n  vector<bool> flag;\r\n  flag.resize(16777216);\r\n  for (int i = 0; i < n; i++) {\r\n    string command, str;\r\n    cin >> command >> str;\r\n    if (command == \"insert\")\r\n      InsertFlag(flag, str);\r\n    else if (command == \"find\")\r\n      FindFlag(flag, str);\r\n  }\r\n}\r\n", "diff": "@@ -3,7 +3,7 @@\n #include <string>\n #include <vector>\n using namespace std;\n-int NumStr(string str) {\n+int NumStr(const string &str) {\n   int n = str.size();\n   int sum = 0;\n   for (int i = 0; i < n; i++) {\n@@ -18,11 +18,11 @@\n   }\n   return sum;\n }\n-void InsertFlag(vector<bool> &flag, string str) {\n+void InsertFlag(vector<bool> &flag, const string &str) {\n   int num_str = NumStr(str);\n   flag[num_str] = true;\n }\n-void FindFlag(vector<bool> &flag, string str) {\n+void FindFlag(vector<bool> &flag, const string &str) {\n   int num_str = NumStr(str);\n   if (flag[num_str] == true)\n     cout << \"yes\" << endl;", "predicted_diffs": [" - -30,6 +30,8 @@\n     cout << \"no\" << endl;\n }\n int main() {\n+  cin.tie(0);\n+  ios_base::sync_with_stdio(false);\n   cin >> n;\n   vector<bool> flag;\n   for (int i = 0; i < n; i++) {"], "optimized_codes": ["#include <cmath>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nint NumStr(string str) {\n  int n = str.size();\n  int sum = 0;\n  for (int i = 0; i < n; i++) {\n    if (str[i] == 'A')\n      sum += pow(4., i) * 1;\n    else if (str[i] == 'C')\n      sum += pow(4., i) * 2;\n    else if (str[i] == 'G')\n      sum += pow(4., i) * 3;\n    else if (str[i] == 'T')\n      sum += pow(4., i) * 4;\n  }\n  return sum;\n}\nvoid InsertFlag(vector<bool> &flag, string str) {\n  int num_str = NumStr(str);\n  flag[num_str] = true;\n}\nvoid FindFlag(vector<bool> &flag, string str) {\n  int num_str = NumStr(str);\n  if (flag[num_str] == true)\n    cout << \"yes\" << endl;\n  else if (flag[num_str] == false)\n    cout << \"no\" << endl;\n}\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  vector<bool> flag;\n  flag.resize(16777216);\n  for (int i = 0; i < n; i++) {\n    string command, str;\n    cin >> command >> str;\n    if (command == \"insert\")\n      InsertFlag(flag, str);\n    else if (command == \"find\")\n      FindFlag(flag, str);\n  }\n}"]}
{"problem_id": "p02295", "original": "#include <complex>\r\n#include <cstdio>\r\n#include <iostream>\r\nusing namespace std;\r\n#define X real()\r\n#define Y imag()\r\n#define EPS (1e-10)\r\ntypedef complex<double> P;\r\ntypedef pair<P, P> L;\r\ndouble dot(P a, P b) { return a.X * b.X + a.Y * b.Y; }\r\ndouble cross(P a, P b) { return a.X * b.Y - a.Y * b.X; }\r\nP projection(P a, P b) { return dot(a, b) / abs(b) / abs(b) * b; }\r\nP intersection(L a, L b) {\r\n  return a.first + abs(cross(b.second - b.first, a.first - b.first) /\r\n                       (abs(cross(b.second - b.first, a.second - b.first)) +\r\n                        abs(cross(b.second - b.first, a.first - b.first)))) *\r\n                       (a.second - a.first);\r\n  ;\r\n}\r\nint main() {\r\n  int q;\r\n  cin >> q;\r\n  P points[4];\r\n  for (int i = 0; i < q; ++i) {\r\n    for (int j = 0; j < 4; ++j) {\r\n      double x, y;\r\n      cin >> x >> y;\r\n      points[j] = P(x, y);\r\n    }\r\n    L l1 = L(points[0], points[1]), l2 = L(points[2], points[3]);\r\n    printf(\"%.10lf %.10lf\\n\", intersection(l1, l2).X, intersection(l1, l2).Y);\r\n  }\r\n  return 0;\r\n}\r\n", "diff": "@@ -11,11 +11,10 @@\n double cross(P a, P b) { return a.X * b.Y - a.Y * b.X; }\n P projection(P a, P b) { return dot(a, b) / abs(b) / abs(b) * b; }\n P intersection(L a, L b) {\n-  return a.first + abs(cross(b.second - b.first, a.first - b.first) /\n-                       (abs(cross(b.second - b.first, a.second - b.first)) +\n-                        abs(cross(b.second - b.first, a.first - b.first)))) *\n+  return a.first + cross(b.second - b.first, a.first - b.first) /\n+                       (-cross(b.second - b.first, a.second - b.first) +\n+                        cross(b.second - b.first, a.first - b.first)) *\n                        (a.second - a.first);\n-  ;\n }\n int main() {\n   int q;", "predicted_diffs": [" - -32,7 +32,7 @@\n   P a = L[0], b = L[--top];\n   double t = abs(cross(a, b));\n   for (int i = 0; i < q; ++i) {\n-    if (i != 0)\n+    if (i != 0)\n       P b = L[i], c = L[(i + 1) % q.size()] - l[i]);\n     if (abs(cross(a, b)) < EPS)\n       t = abs(cross(a, b)));"], "optimized_codes": ["#include <complex>\n#include <cstdio>\n#include <iostream>\nusing namespace std;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ndouble dot(P a, P b) { return a.X * b.X + a.Y * b.Y; }\ndouble cross(P a, P b) { return a.X * b.Y - a.Y * b.X; }\nP projection(P a, P b) { return dot(a, b) / abs(b) / abs(b) * b; }\nP intersection(L a, L b) {\n  return a.first + abs(cross(b.second - b.first, a.first - b.first) /\n                       (abs(cross(b.second - b.first, a.second - b.first)) +\n                        abs(cross(b.second - b.first, a.first - b.first)))) *\n                       (a.second - a.first);\n  ;\n}\nint main() {\n  int q;\n  cin >> q;\n  P points[4];\n  for (int i = 0; i < q; ++i) {\n    for (int j = 0; j < 4; ++j) {\n      double x, y;\n      cin >> x >> y;\n      points[j] = P(x, y);\n    }\n    L l1 = L(points[0], points[1]), l2 = L(points[2], points[3]);\n    printf(\"%.10lf %.10lf\\n\", intersection(l1, l2).X, intersection(l1, l2).Y);\n  }\n  return 0;\n}"]}
{"problem_id": "p02299", "original": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef complex<double> P;\r\ntypedef vector<P> vec;\r\ndouble eps = 1e-8;\r\ndouble PI = acos(-1);\r\nbool eq(double a, double b) { return (b - a < eps && a - b < eps); }\r\ndouble dot(P a, P b) { return real(b * conj(a)); }\r\ndouble cross(P a, P b) { return imag(b * conj(a)); }\r\nP project(P a, P b, P c) {\r\n  b -= a;\r\n  c -= a;\r\n  return a + b * real(c / b);\r\n}\r\nP reflect(P a, P b, P c) {\r\n  b -= a;\r\n  c -= a;\r\n  return a + conj(c / b) * b;\r\n}\r\nint ccw(P a, P b, P c) {\r\n  b -= a, c -= a, a = c * conj(b);\r\n  if (a.imag() > eps)\r\n    return 1;\r\n  if (a.imag() < -eps)\r\n    return -1;\r\n  if (a.real() < -eps)\r\n    return 2;\r\n  if (abs(b) + eps < abs(c))\r\n    return -2;\r\n  return 0;\r\n}\r\ndouble dist(P a, P b, P c) {\r\n  if (dot(b - a, c - a) < 0)\r\n    return abs(c - a);\r\n  if (dot(a - b, c - b) < 0)\r\n    return abs(c - b);\r\n  return abs(cross(b - a, c - a)) / abs(b - a);\r\n}\r\nbool isintersect(P a, P b, P c, P d) {\r\n  return ((ccw(a, b, c) * ccw(a, b, d) <= 0) &&\r\n          (ccw(c, d, a) * ccw(c, d, b) <= 0));\r\n}\r\nP intersect(P a, P b, P c, P d) {\r\n  a -= d;\r\n  b -= d;\r\n  c -= d;\r\n  return d + a + (b - a) * imag(a / c) / imag(a / c - b / c);\r\n}\r\ndouble dist(P a, P b, P c, P d) {\r\n  if (isintersect(a, b, c, d))\r\n    return 0;\r\n  double ab = min(dist(a, b, c), dist(a, b, d));\r\n  double cd = min(dist(c, d, a), dist(c, d, b));\r\n  return min(ab, cd);\r\n}\r\ndouble calcArea(vec &t) {\r\n  double res = 0;\r\n  int n = t.size();\r\n  for (int i = 0; i < n; i++)\r\n    res += cross(t[i], t[(i + 1 == n ? 0 : i + 1)]);\r\n  return abs(res / 2.0);\r\n}\r\ndouble Arg(P a, P b, P c) {\r\n  b -= a, c -= a;\r\n  return arg(c * conj(b));\r\n}\r\nint inPolygon(vec &t, P p) {\r\n  double sum = 0;\r\n  for (int i = 0; i < (int)t.size(); i++) {\r\n    P a = t[i], b = (i == 0 ? t.back() : t[i - 1]);\r\n    if (ccw(a, b, p) == 0)\r\n      return 1;\r\n    sum += Arg(p, a, b);\r\n  }\r\n  if (abs(sum) < eps)\r\n    return 0;\r\n  else\r\n    return 2;\r\n}\r\nint main() {\r\n  int n;\r\n  cin >> n;\r\n  vec t;\r\n  double x, y;\r\n  for (int i = 0; i < n; i++) {\r\n    cin >> x >> y;\r\n    t.push_back(P(x, y));\r\n  }\r\n  int q;\r\n  cin >> q;\r\n  while (q--) {\r\n    cin >> x >> y;\r\n    cout << inPolygon(t, P(x, y)) << endl;\r\n  }\r\n  return 0;\r\n}\r\n", "diff": "@@ -65,9 +65,10 @@\n   return arg(c * conj(b));\n }\n int inPolygon(vec &t, P p) {\n+  int n = t.size();\n   double sum = 0;\n-  for (int i = 0; i < (int)t.size(); i++) {\n-    P a = t[i], b = (i == 0 ? t.back() : t[i - 1]);\n+  for (int i = 0; i < n; i++) {\n+    P a = t[i], b = t[(i + 1 == n ? 0 : i + 1)];\n     if (ccw(a, b, p) == 0)\n       return 1;\n     sum += Arg(p, a, b);", "predicted_diffs": [" - -10,6 +10,7 @@\n double eps = 1e-8;\n double PI = acos(-1);\n bool eq(double a, double b) { return (b - a < eps && a - b < eps); }\n+bool eq(P a, P b) { return (abs(a - b) < eps); }\n double dot(P a, P b) { return real(b * conj(a)); }\n double cross(P a, P b) { return imag(b * conj(a)); }\n P project(P a, P b, P c) {\n@@ -141,6 +142,15 @@\n   vec ans = ConvexHull2(t);\n   vec ans2 = ConvexHull(t);\n   assert(eq(calcArea(ans), calcArea(ans2)));\n+  int nn = ans2.size();\n+  for (int i = 0; i < nn; i++) {\n+    int j = (i + 1) % nn, k = (j + 1) % nn;\n+    assert(!eq(ans2[i], ans2[j]));\n+    assert(!eq(ans2[i], ans2[k]));\n+    if (eq(cross(ans2[i] - ans2[j], ans2[j] - ans2[k]), 0)) {\n+      assert(0);\n+    }\n+  }\n   cout << ans.size() << endl;\n   for (int i = 0; i < (int)ans.size(); i++) {\n     cout << (int)ans[i].real() << ' ' << (int)ans[i].imag() << endl;"], "optimized_codes": ["#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> vec;\ndouble eps = 1e-8;\ndouble PI = acos(-1);\nbool eq(double a, double b) { return (b - a < eps && a - b < eps); }\ndouble dot(P a, P b) { return real(b * conj(a)); }\ndouble cross(P a, P b) { return imag(b * conj(a)); }\nP project(P a, P b, P c) {\n  b -= a;\n  c -= a;\n  return a + b * real(c / b);\n}\nP reflect(P a, P b, P c) {\n  b -= a;\n  c -= a;\n  return a + conj(c / b) * b;\n}\nint ccw(P a, P b, P c) {\n  b -= a, c -= a, a = c * conj(b);\n  if (a.imag() > eps)\n    return 1;\n  if (a.imag() < -eps)\n    return -1;\n  if (a.real() < -eps)\n    return 2;\n  if (abs(b) + eps < abs(c))\n    return -2;\n  return 0;\n}\ndouble dist(P a, P b, P c) {\n  if (dot(b - a, c - a) < 0)\n    return abs(c - a);\n  if (dot(a - b, c - b) < 0)\n    return abs(c - b);\n  return abs(cross(b - a, c - a)) / abs(b - a);\n}\nbool isintersect(P a, P b, P c, P d) {\n  return ((ccw(a, b, c) * ccw(a, b, d) <= 0) &&\n          (ccw(c, d, a) * ccw(c, d, b) <= 0));\n}\nP intersect(P a, P b, P c, P d) {\n  a -= d;\n  b -= d;\n  c -= d;\n  return d + a + (b - a) * imag(a / c) / imag(a / c - b / c);\n}\ndouble dist(P a, P b, P c, P d) {\n  if (isintersect(a, b, c, d))\n    return 0;\n  double ab = min(dist(a, b, c), dist(a, b, d));\n  double cd = min(dist(c, d, a), dist(c, d, b));\n  return min(ab, cd);\n}\ndouble calcArea(vec &t) {\n  double res = 0;\n  int n = t.size();\n  for (int i = 0; i < n; i++)\n    res += cross(t[i], t[(i + 1 == n ? 0 : i + 1)]);\n  return abs(res / 2.0);\n}\ndouble Arg(P a, P b, P c) {\n  b -= a, c -= a;\n  return arg(c * conj(b));\n}\nint inPolygon(vec &t, P p) {\n  double sum = 0;\n  for (int i = 0; i < (int)t.size(); i++) {\n    P a = t[i], b = (i == 0 ? t.back() : t[i - 1]);\n    if (ccw(a, b, p) == 0)\n      return 1;\n    sum += Arg(p, a, b);\n  }\n  if (abs(sum) < eps)\n    return 0;\n  else\n    return 2;\n}\nint main() {\n  int n;\n  cin >> n;\n  vec t;\n  double x, y;\n  for (int i = 0; i < n; i++) {\n    cin >> x >> y;\n    t.push_back(P(x, y));\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    cin >> x >> y;\n    cout << inPolygon(t, P(x, y)) << endl;\n  }\n  return 0;\n}\n  vec ans = ConvexHull2(t);\n  vec ans2 = ConvexHull(t);\n  assert(eq(calcArea(ans), calcArea(ans2)));\n  int nn = ans2.size();\n  for (int i = 0; i < nn; i++) {\n    int j = (i + 1) % nn, k = (j + 1) % nn;\n    assert(!eq(ans2[i], ans2[j]));\n    assert(!eq(ans2[i], ans2[k]));\n    if (eq(cross(ans2[i] - ans2[j], ans2[j] - ans2[k]), 0)) {\n      assert(0);\n    }\n  }\n  cout << ans.size() << endl;\n  for (int i = 0; i < (int)ans.size(); i++) {\n    cout << (int)ans[i].real() << ' ' << (int)ans[i].imag() << endl;"]}
{"problem_id": "p00189", "original": "main() {\r\n  int i, j, n, k, K, a, b, d, dist[10][10];\r\n  for (; scanf(\"%d\", &k), k;) {\r\n    memset(dist, 11, sizeof(dist));\r\n    for (i = 0; i <= 9; i++)\r\n      dist[i][i] = 0;\r\n    for (n = 0; k; k--) {\r\n      scanf(\"%d%d%d\", &a, &b, &d);\r\n      if (n < a)\r\n        n = a;\r\n      if (n < b)\r\n        n = b;\r\n      dist[a][b] = d, dist[b][a] = d;\r\n    }\r\n    {\r\n      int k, i, j;\r\n      for (k = 0; k <= n; k++)\r\n        for (i = 0; i <= n; i++)\r\n          for (j = 0; j <= n; j++)\r\n            if (dist[i][j] > dist[i][k] + dist[k][j])\r\n              dist[i][j] = dist[i][k] + dist[k][j];\r\n    }\r\n    for (k = 99999999, i = 0; i <= n; i++) {\r\n      for (d = j = 0; j <= n; j++)\r\n        d += dist[i][j];\r\n      if (k > d)\r\n        k = d, K = i;\r\n    }\r\n    printf(\"%d %d\\n\", K, k);\r\n  }\r\n  exit(0);\r\n}\r\n", "diff": "@@ -6,8 +6,6 @@\n       dist[i][i] = 0;\n     for (n = 0; k; k--) {\n       scanf(\"%d%d%d\", &a, &b, &d);\n-      if (n < a)\n-        n = a;\n       if (n < b)\n         n = b;\n       dist[a][b] = d, dist[b][a] = d;", "predicted_diffs": [" - -1,4 +1,4 @@\n-#include <stdio.h>\n+#include <cstdio>\n int main() {\n   int i, j, k, d, x, a, b, d;\n   while (scanf(\"%d%d\", &n, &k), n) {"], "optimized_codes": ["main() {\n  int i, j, n, k, K, a, b, d, dist[10][10];\n  for (; scanf(\"%d\", &k), k;) {\n    memset(dist, 11, sizeof(dist));\n    for (i = 0; i <= 9; i++)\n      dist[i][i] = 0;\n    for (n = 0; k; k--) {\n      scanf(\"%d%d%d\", &a, &b, &d);\n      if (n < a)\n        n = a;\n      if (n < b)\n        n = b;\n      dist[a][b] = d, dist[b][a] = d;\n    }\n    {\n      int k, i, j;\n      for (k = 0; k <= n; k++)\n        for (i = 0; i <= n; i++)\n          for (j = 0; j <= n; j++)\n            if (dist[i][j] > dist[i][k] + dist[k][j])\n              dist[i][j] = dist[i][k] + dist[k][j];\n    }\n    for (k = 99999999, i = 0; i <= n; i++) {\n      for (d = j = 0; j <= n; j++)\n        d += dist[i][j];\n      if (k > d)\n        k = d, K = i;\n    }\n    printf(\"%d %d\\n\", K, k);\n  }\n  exit(0);\n}"]}
{"problem_id": "p00459", "original": "#include <algorithm>\r\n#include <cstdio>\r\n#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\nint main() {\r\n  int n, m, p, q, r, x, y, t;\r\n  vector<int>::iterator itx, ity, it;\r\n  for (; cin >> n >> m >> p >> q >> r; cout << x << endl) {\r\n    vector<int> v1, v2;\r\n    v1.push_back(0);\r\n    v1.push_back(r);\r\n    for (; m--; v2.clear()) {\r\n      cin >> x >> y;\r\n      itx = upper_bound(v1.begin(), v1.end(), x);\r\n      ity = upper_bound(v1.begin(), v1.end(), y);\r\n      if (ity - v1.begin() + 1 & 1)\r\n        v2.push_back(0);\r\n      v2.push_back(0);\r\n      for (it = ity; it != v1.end(); ++it)\r\n        v2.push_back(*it - y);\r\n      if (v1.end() - itx & 1)\r\n        v2.push_back(n - y);\r\n      for (it = itx; it != ity; ++it)\r\n        v2.push_back(*it - x + n - y);\r\n      it = v1.begin();\r\n      if (ity - v1.begin() & 1)\r\n        ++it;\r\n      if (!it[1]) {\r\n        ++it;\r\n        ++it;\r\n      }\r\n      if (*it + n - x == v2.back()) {\r\n        ++it;\r\n        v2.pop_back();\r\n      }\r\n      for (; it != itx; ++it)\r\n        v2.push_back(*it + n - x);\r\n      v1.swap(v2);\r\n    }\r\n    v1.insert(upper_bound(v1.begin(), v1.end(), p - 1), 2, p - 1);\r\n    v1.insert(lower_bound(v1.begin(), v1.end(), q), q);\r\n    v1.push_back(n);\r\n    it = upper_bound(v1.begin(), v1.end(), p - 1);\r\n    if (it - v1.begin() & 1)\r\n      --it;\r\n    for (x = 0; *it < q; ++it) {\r\n      m = *it;\r\n      ++it;\r\n      x += *it - m;\r\n    }\r\n  }\r\n}\r\n", "diff": "@@ -1,5 +1,4 @@\n #include <algorithm>\n-#include <cstdio>\n #include <iostream>\n #include <vector>\n using namespace std;", "predicted_diffs": [" - -40,10 +40,7 @@\n     it = upper_bound(v1.begin(), v1.end(), p - 1);\n     if (it - v1.begin() & 1)\n       --it;\n-    for (x = 0; *it < q; ++it) {\n-      m = *it;\n-      ++it;\n-      x += *it - m;\n-    }\n+    for (x = 0; *it < q; ++it)\n+      m = *it++, x += *it - m;\n   }\n }"], "optimized_codes": ["#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  int n, m, p, q, r, x, y, t;\n  vector<int>::iterator itx, ity, it;\n  for (; cin >> n >> m >> p >> q >> r; cout << x << endl) {\n    vector<int> v1, v2;\n    v1.push_back(0);\n    v1.push_back(r);\n    for (; m--; v2.clear()) {\n      cin >> x >> y;\n      itx = upper_bound(v1.begin(), v1.end(), x);\n      ity = upper_bound(v1.begin(), v1.end(), y);\n      if (ity - v1.begin() + 1 & 1)\n        v2.push_back(0);\n      v2.push_back(0);\n      for (it = ity; it != v1.end(); ++it)\n        v2.push_back(*it - y);\n      if (v1.end() - itx & 1)\n        v2.push_back(n - y);\n      for (it = itx; it != ity; ++it)\n        v2.push_back(*it - x + n - y);\n      it = v1.begin();\n      if (ity - v1.begin() & 1)\n        ++it;\n      if (!it[1]) {\n        ++it;\n        ++it;\n      }\n      if (*it + n - x == v2.back()) {\n        ++it;\n        v2.pop_back();\n      }\n      for (; it != itx; ++it)\n        v2.push_back(*it + n - x);\n      v1.swap(v2);\n    }\n    v1.insert(upper_bound(v1.begin(), v1.end(), p - 1), 2, p - 1);\n    v1.insert(lower_bound(v1.begin(), v1.end(), q), q);\n    v1.push_back(n);\n    it = upper_bound(v1.begin(), v1.end(), p - 1);\n    if (it - v1.begin() & 1)\n      --it;\n    for (x = 0; *it < q; ++it) {\n      m = *it;\n      ++it;\n      x += *it - m;\n    }\n  }\n}"]}
{"problem_id": "p02365", "original": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nint INF = 1e9;\r\nstruct UnionFind {\r\n  vector<int> par, rank;\r\n  void init(int n) {\r\n    par.clear();\r\n    rank.clear();\r\n    par.resize(n);\r\n    rank.resize(n);\r\n    for (int i = 0; i < n; i++) {\r\n      par[i] = i;\r\n      rank[i] = 1;\r\n    }\r\n  }\r\n  int find(int x) {\r\n    if (x == par[x])\r\n      return x;\r\n    return par[x] = find(par[x]);\r\n  }\r\n  bool same(int x, int y) { return (find(x) == find(y)); }\r\n  void unite(int x, int y) {\r\n    x = find(x);\r\n    y = find(y);\r\n    if (x == y)\r\n      return;\r\n    if (rank[x] < rank[y])\r\n      swap(x, y);\r\n    par[y] = x;\r\n    rank[x] += rank[y];\r\n  }\r\n};\r\nstruct edge {\r\n  int from, to, cost, id;\r\n  bool operator<(const edge e) const { return cost > e.cost; }\r\n};\r\ntypedef priority_queue<edge> prque;\r\ntypedef prque *Prque;\r\ntypedef vector<edge> Node;\r\ntypedef vector<Node> Graph;\r\nPrque Merge(vector<Prque> &Q, vector<edge> &ev, int A, int C) {\r\n  if (Q[C]->size() < Q[A]->size()) {\r\n    while (!Q[C]->empty()) {\r\n      edge e = Q[C]->top();\r\n      e.cost -= ev[C].cost;\r\n      e.cost += ev[A].cost;\r\n      Q[A]->push(e);\r\n      Q[C]->pop();\r\n    }\r\n    ev[C].cost = ev[A].cost;\r\n    return Q[A];\r\n  } else {\r\n    while (!Q[A]->empty()) {\r\n      edge e = Q[A]->top();\r\n      e.cost -= ev[A].cost;\r\n      e.cost += ev[C].cost;\r\n      Q[C]->push(e);\r\n      Q[A]->pop();\r\n    }\r\n    return Q[C];\r\n  }\r\n}\r\nint solve(Graph &G, vector<edge> &edges, int root) {\r\n  int n = G.size(), res = 0;\r\n  vector<int> used(n, 0);\r\n  vector<edge> ev(n, (edge){0, 0, 0, -1});\r\n  vector<prque> pool(n);\r\n  vector<Prque> Q(n);\r\n  for (int i = 0; i < n; i++)\r\n    Q[i] = &pool[i];\r\n  UnionFind uf;\r\n  uf.init(n);\r\n  for (int i = 0; i < (int)edges.size(); i++) {\r\n    edge e = edges[i];\r\n    Q[e.to]->push(e);\r\n  }\r\n  used[root] = 2;\r\n  for (int Pos = 0; Pos < n; Pos++) {\r\n    if (used[Pos] == 2)\r\n      continue;\r\n    int pos = Pos;\r\n    vector<int> path;\r\n    while (used[pos] != 2) {\r\n      pos = uf.find(pos);\r\n      used[pos] = 1;\r\n      path.push_back(pos);\r\n      if (Q[pos]->empty()) {\r\n        return INF;\r\n      }\r\n      edge e = Q[pos]->top();\r\n      Q[pos]->pop();\r\n      e.cost -= ev[pos].cost;\r\n      if (uf.same(e.from, pos))\r\n        continue;\r\n      int tmpcost = ev[pos].cost;\r\n      res += e.cost;\r\n      e.cost += tmpcost;\r\n      ev[pos] = e;\r\n      if (used[uf.find(e.from)] == 2)\r\n        break;\r\n      if (used[uf.find(e.from)] == 0) {\r\n        pos = e.from;\r\n        continue;\r\n      }\r\n      int pre = uf.find(e.from);\r\n      for (int i = 0; i < 100; i++) {\r\n        if (!uf.same(pre, pos)) {\r\n          int A = uf.find(pre), B = uf.find(pos);\r\n          uf.unite(A, B);\r\n          int C = uf.find(A);\r\n          Prque tmp = NULL;\r\n          if (B == C)\r\n            tmp = Merge(Q, ev, A, C);\r\n          else if (A == C)\r\n            tmp = Merge(Q, ev, B, C);\r\n          else\r\n            assert(0);\r\n          Q[C] = tmp;\r\n        }\r\n        pre = uf.find(ev[pre].from);\r\n      }\r\n    }\r\n    for (int i = 0; i < (int)path.size(); i++)\r\n      used[path[i]] = 2;\r\n  }\r\n  return res;\r\n}\r\nint main() {\r\n  int V, E, r;\r\n  vector<edge> edges;\r\n  Graph G;\r\n  cin >> V >> E >> r;\r\n  G.resize(V);\r\n  for (int i = 0; i < E; i++) {\r\n    int a, b, c;\r\n    cin >> a >> b >> c;\r\n    G[a].push_back((edge){a, b, c, i});\r\n    edges.push_back((edge){a, b, c, i});\r\n  }\r\n  cout << solve(G, edges, r) << endl;\r\n  return 0;\r\n}\r\n", "diff": "@@ -103,7 +103,11 @@\n         continue;\n       }\n       int pre = uf.find(e.from);\n-      for (int i = 0; i < 100; i++) {\n+      set<int> mp;\n+      while (1) {\n+        if (mp.count(pre))\n+          break;\n+        mp.insert(pre);\n         if (!uf.same(pre, pos)) {\n           int A = uf.find(pre), B = uf.find(pos);\n           uf.unite(A, B);", "predicted_diffs": [" - -103,7 +103,11 @@\n         continue;\n       }\n       int pre = uf.find(e.from);\n-      for (int i = 0; i < 100; i++) {\n+      set<int> mp;\n+      while (1) {\n+        if (mp.count(pre))\n+          break;\n+        mp.insert(pre);\n         if (!uf.same(pre, pos)) {\n           int A = uf.find(pre), B = uf.find(pos);\n           uf.unite(A, B);"], "optimized_codes": ["#include <bits/stdc++.h>\nusing namespace std;\nint INF = 1e9;\nstruct UnionFind {\n  vector<int> par, rank;\n  void init(int n) {\n    par.clear();\n    rank.clear();\n    par.resize(n);\n    rank.resize(n);\n    for (int i = 0; i < n; i++) {\n      par[i] = i;\n      rank[i] = 1;\n    }\n  }\n  int find(int x) {\n    if (x == par[x])\n      return x;\n    return par[x] = find(par[x]);\n  }\n  bool same(int x, int y) { return (find(x) == find(y)); }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y)\n      return;\n    if (rank[x] < rank[y])\n      swap(x, y);\n    par[y] = x;\n    rank[x] += rank[y];\n  }\n};\nstruct edge {\n  int from, to, cost, id;\n  bool operator<(const edge e) const { return cost > e.cost; }\n};\ntypedef priority_queue<edge> prque;\ntypedef prque *Prque;\ntypedef vector<edge> Node;\ntypedef vector<Node> Graph;\nPrque Merge(vector<Prque> &Q, vector<edge> &ev, int A, int C) {\n  if (Q[C]->size() < Q[A]->size()) {\n    while (!Q[C]->empty()) {\n      edge e = Q[C]->top();\n      e.cost -= ev[C].cost;\n      e.cost += ev[A].cost;\n      Q[A]->push(e);\n      Q[C]->pop();\n    }\n    ev[C].cost = ev[A].cost;\n    return Q[A];\n  } else {\n    while (!Q[A]->empty()) {\n      edge e = Q[A]->top();\n      e.cost -= ev[A].cost;\n      e.cost += ev[C].cost;\n      Q[C]->push(e);\n      Q[A]->pop();\n    }\n    return Q[C];\n  }\n}\nint solve(Graph &G, vector<edge> &edges, int root) {\n  int n = G.size(), res = 0;\n  vector<int> used(n, 0);\n  vector<edge> ev(n, (edge){0, 0, 0, -1});\n  vector<prque> pool(n);\n  vector<Prque> Q(n);\n  for (int i = 0; i < n; i++)\n    Q[i] = &pool[i];\n  UnionFind uf;\n  uf.init(n);\n  for (int i = 0; i < (int)edges.size(); i++) {\n    edge e = edges[i];\n    Q[e.to]->push(e);\n  }\n  used[root] = 2;\n  for (int Pos = 0; Pos < n; Pos++) {\n    if (used[Pos] == 2)\n      continue;\n    int pos = Pos;\n    vector<int> path;\n    while (used[pos] != 2) {\n      pos = uf.find(pos);\n      used[pos] = 1;\n      path.push_back(pos);\n      if (Q[pos]->empty()) {\n        return INF;\n      }\n      edge e = Q[pos]->top();\n      Q[pos]->pop();\n      e.cost -= ev[pos].cost;\n      if (uf.same(e.from, pos))\n        continue;\n      int tmpcost = ev[pos].cost;\n      res += e.cost;\n      e.cost += tmpcost;\n      ev[pos] = e;\n      if (used[uf.find(e.from)] == 2)\n        break;\n      if (used[uf.find(e.from)] == 0) {\n        pos = e.from;\n        continue;\n      }\n      int pre = uf.find(e.from);\n      for (int i = 0; i < 100; i++) {\n        if (!uf.same(pre, pos)) {\n          int A = uf.find(pre), B = uf.find(pos);\n          uf.unite(A, B);\n          int C = uf.find(A);\n          Prque tmp = NULL;\n          if (B == C)\n            tmp = Merge(Q, ev, A, C);\n          else if (A == C)\n            tmp = Merge(Q, ev, B, C);\n          else\n            assert(0);\n          Q[C] = tmp;\n        }\n        pre = uf.find(ev[pre].from);\n      }\n    }\n    for (int i = 0; i < (int)path.size(); i++)\n      used[path[i]] = 2;\n  }\n  return res;\n}\nint main() {\n  int V, E, r;\n  vector<edge> edges;\n  Graph G;\n  cin >> V >> E >> r;\n  G.resize(V);\n  for (int i = 0; i < E; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    G[a].push_back((edge){a, b, c, i});\n    edges.push_back((edge){a, b, c, i});\n  }\n  cout << solve(G, edges, r) << endl;\n  return 0;\n}"]}
{"problem_id": "p00146", "original": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> Pi;\r\ntypedef pair<int, Pi> Pii;\r\n#define fr first\r\n#define sc second\r\n#define INF 1e300\r\nint main() {\r\n  int n;\r\n  int num[15], dist[15], box[15];\r\n  double dp[1 << 15][15];\r\n  int prev[1 << 15][15];\r\n  long double speed[1 << 15];\r\n  fill_n(*prev, 15 * (1 << 15), -1);\r\n  fill_n(*dp, 15 * (1 << 15), INF);\r\n  cin >> n;\r\n  for (int i = 0; i < n; i++) {\r\n    cin >> num[i] >> dist[i] >> box[i];\r\n  }\r\n  for (int i = 0; i < 1 << n; i++) {\r\n    int ret = 0;\r\n    for (int j = 0; j < n; j++) {\r\n      if (i >> j & 1)\r\n        continue;\r\n      ret += box[j];\r\n    }\r\n    speed[i] = (7.0 + 2 * ret) / 200.0;\r\n  }\r\n  for (int i = 0; i < n; i++) {\r\n    dp[1 << i][i] = 0;\r\n  }\r\n  for (int bit = 0; bit < 1 << n; bit++) {\r\n    for (int i = 0; i < n; i++) {\r\n      if (!((bit >> i) & 1))\r\n        continue;\r\n      for (int k = 0; k < n; k++) {\r\n        double power = abs(dist[i] - dist[k]) * speed[bit];\r\n        if ((bit >> k) & 1)\r\n          continue;\r\n        int nxbit = bit | (1 << k);\r\n        if (dp[nxbit][k] > dp[bit][i] + power) {\r\n          dp[nxbit][k] = dp[bit][i] + power;\r\n          prev[nxbit][k] = i;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  int pos = 0;\r\n  int bit = (1 << n) - 1;\r\n  for (int i = 1; i < n; i++) {\r\n    if (dp[bit][pos] > dp[bit][i])\r\n      pos = i;\r\n  }\r\n  queue<int> st;\r\n  while (pos != -1) {\r\n    st.push(num[pos]);\r\n    int foo = prev[bit][pos];\r\n    bit ^= 1 << pos;\r\n    pos = foo;\r\n  }\r\n  while (st.size() > 1) {\r\n    cout << st.front() << \" \";\r\n    st.pop();\r\n  }\r\n  cout << st.front() << endl;\r\n  return (0);\r\n}\r\n", "diff": "@@ -4,13 +4,14 @@\n typedef pair<int, Pi> Pii;\n #define fr first\n #define sc second\n-#define INF 1e300\n+#define EPS 1e-8\n+#define INF 1 << 30\n int main() {\n   int n;\n   int num[15], dist[15], box[15];\n-  double dp[1 << 15][15];\n+  int dp[1 << 15][15];\n   int prev[1 << 15][15];\n-  long double speed[1 << 15];\n+  int speed[1 << 15];\n   fill_n(*prev, 15 * (1 << 15), -1);\n   fill_n(*dp, 15 * (1 << 15), INF);\n   cin >> n;\n@@ -24,7 +25,7 @@\n         continue;\n       ret += box[j];\n     }\n-    speed[i] = (7.0 + 2 * ret) / 200.0;\n+    speed[i] = 7 + ret * 2;\n   }\n   for (int i = 0; i < n; i++) {\n     dp[1 << i][i] = 0;\n@@ -34,7 +35,7 @@\n       if (!((bit >> i) & 1))\n         continue;\n       for (int k = 0; k < n; k++) {\n-        double power = abs(dist[i] - dist[k]) * speed[bit];\n+        int power = abs(dist[i] - dist[k]) * speed[bit];\n         if ((bit >> k) & 1)\n           continue;\n         int nxbit = bit | (1 << k);", "predicted_diffs": [" - -10,7 +10,7 @@\n   int number[15], dist[15];\n   double dp[1 << 15][15];\n   for (int i = 0; i < n; i++) {\n-    for (int j = 0; j < n; j++) {\n+    for (int j = 0; j < n; j++) {\n       dist[i][j] = INF;\n     }\n     for (int i = 0; i < n; i++) {"], "optimized_codes": ["#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> Pi;\ntypedef pair<int, Pi> Pii;\n#define fr first\n#define sc second\n#define INF 1e300\nint main() {\n  int n;\n  int num[15], dist[15], box[15];\n  double dp[1 << 15][15];\n  int prev[1 << 15][15];\n  long double speed[1 << 15];\n  fill_n(*prev, 15 * (1 << 15), -1);\n  fill_n(*dp, 15 * (1 << 15), INF);\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> num[i] >> dist[i] >> box[i];\n  }\n  for (int i = 0; i < 1 << n; i++) {\n    int ret = 0;\n    for (int j = 0; j < n; j++) {\n      if (i >> j & 1)\n        continue;\n      ret += box[j];\n    }\n    speed[i] = (7.0 + 2 * ret) / 200.0;\n  }\n  for (int i = 0; i < n; i++) {\n    dp[1 << i][i] = 0;\n  }\n  for (int bit = 0; bit < 1 << n; bit++) {\n    for (int i = 0; i < n; i++) {\n      if (!((bit >> i) & 1))\n        continue;\n      for (int k = 0; k < n; k++) {\n        double power = abs(dist[i] - dist[k]) * speed[bit];\n        if ((bit >> k) & 1)\n          continue;\n        int nxbit = bit | (1 << k);\n        if (dp[nxbit][k] > dp[bit][i] + power) {\n          dp[nxbit][k] = dp[bit][i] + power;\n          prev[nxbit][k] = i;\n        }\n      }\n    }\n  }\n  int pos = 0;\n  int bit = (1 << n) - 1;\n  for (int i = 1; i < n; i++) {\n    if (dp[bit][pos] > dp[bit][i])\n      pos = i;\n  }\n  queue<int> st;\n  while (pos != -1) {\n    st.push(num[pos]);\n    int foo = prev[bit][pos];\n    bit ^= 1 << pos;\n    pos = foo;\n  }\n  while (st.size() > 1) {\n    cout << st.front() << \" \";\n    st.pop();\n  }\n  cout << st.front() << endl;\n  return (0);\n}"]}
{"problem_id": "p02289", "original": "#include <cassert>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <queue>\r\ntemplate <typename T> class TBinaryHeap {\r\n  std::vector<T> FArray;\r\n\r\npublic:\r\n  TBinaryHeap() {\r\n    FArray.reserve(2000000);\r\n    FArray.resize(1);\r\n  }\r\n  void push(const T &Value) {\r\n    std::size_t Index = FArray.size();\r\n    FArray.push_back(Value);\r\n    std::size_t Parent;\r\n    while (Index > 1) {\r\n      Parent = Index / 2;\r\n      if (FArray[Index] < FArray[Parent])\r\n        return;\r\n      std::swap(FArray[Index], FArray[Parent]);\r\n      Index = Parent;\r\n    }\r\n  }\r\n  void pop() {\r\n    assert(FArray.size() >= 1);\r\n    FArray[1] = FArray.back();\r\n    FArray.pop_back();\r\n    std::size_t Size = FArray.size();\r\n    std::size_t Index = 1;\r\n    std::size_t Left, Right;\r\n    while (Index < Size) {\r\n      Left = Index * 2;\r\n      Right = Left + 1;\r\n      if (Left >= Size)\r\n        break;\r\n      std::size_t Target = Right >= Size                  ? Left\r\n                           : FArray[Left] > FArray[Right] ? Left\r\n                                                          : Right;\r\n      if (FArray[Target] <= FArray[Index])\r\n        break;\r\n      std::swap(FArray[Index], FArray[Target]);\r\n      Index = Target;\r\n    }\r\n  }\r\n  const T &top() { return FArray[1]; }\r\n};\r\nint main() {\r\n  char Line[19];\r\n  int Value;\r\n  TBinaryHeap<int> S;\r\n  while (1) {\r\n    std::fgets(Line, 19, stdin);\r\n    if (Line[0] == 'i') {\r\n      S.push(std::atoi(&Line[7]));\r\n    } else if (Line[1] == 'x') {\r\n      std::printf(\"%d\\n\", S.top());\r\n      S.pop();\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n", "diff": "@@ -28,10 +28,9 @@\n     FArray.pop_back();\n     std::size_t Size = FArray.size();\n     std::size_t Index = 1;\n-    std::size_t Left, Right;\n     while (Index < Size) {\n-      Left = Index * 2;\n-      Right = Left + 1;\n+      std::size_t Left = Index * 2;\n+      std::size_t Right = Left + 1;\n       if (Left >= Size)\n         break;\n       std::size_t Target = Right >= Size                  ? Left", "predicted_diffs": [" - -1,4 +1,3 @@\n-#include <cassert>\n #include <cstdio>\n #include <cstdlib>\n #include <queue>\n@@ -22,7 +21,6 @@\n     }\n   }\n   void pop() {\n-    assert(FArray.size() >= 1);\n     FArray[1] = FArray.back();\n     FArray.pop_back();\n     std::size_t Size = FArray.size();"], "optimized_codes": ["#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <queue>\ntemplate <typename T> class TBinaryHeap {\n  std::vector<T> FArray;\n\npublic:\n  TBinaryHeap() {\n    FArray.reserve(2000000);\n    FArray.resize(1);\n  }\n  void push(const T &Value) {\n    std::size_t Index = FArray.size();\n    FArray.push_back(Value);\n    std::size_t Parent;\n    while (Index > 1) {\n      Parent = Index / 2;\n      if (FArray[Index] < FArray[Parent])\n        return;\n      std::swap(FArray[Index], FArray[Parent]);\n    }\n  }\n  void pop() {\n    FArray[1] = FArray.back();\n    FArray.pop_back();\n    std::size_t Size = FArray.size();\n    std::size_t Size = FArray.size();\n    std::size_t Index = 1;\n    std::size_t Left, Right;\n    while (Index < Size) {\n      Left = Index * 2;\n      Right = Left + 1;\n      if (Left >= Size)\n        break;\n      std::size_t Target = Right >= Size                  ? Left\n                           : FArray[Left] > FArray[Right] ? Left\n                                                          : Right;\n      if (FArray[Target] <= FArray[Index])\n        break;\n      std::swap(FArray[Index], FArray[Target]);\n      Index = Target;\n    }\n  }\n  const T &top() { return FArray[1]; }\n};\nint main() {\n  char Line[19];\n  int Value;\n  TBinaryHeap<int> S;\n  while (1) {\n    std::fgets(Line, 19, stdin);\n    if (Line[0] == 'i') {\n      S.push(std::atoi(&Line[7]));\n    } else if (Line[1] == 'x') {\n      std::printf(\"%d\\n\", S.top());\n      S.pop();\n    } else {\n      break;\n    }\n  }\n  return 0;\n}"]}
{"problem_id": "p02238", "original": "#include <algorithm>\r\n#include <bitset>\r\n#include <climits>\r\n#include <cmath>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <iomanip>\r\n#include <iostream>\r\n#include <map>\r\n#include <numeric>\r\n#include <queue>\r\n#include <set>\r\n#include <stack>\r\n#include <string>\r\n#include <vector>\r\n#define REP(i, n) for (int i = 0; i < (n); i++)\r\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\r\n#define RREP(i, n) for (int i = (n)-1; i >= 0; i--)\r\n#define RFOR(i, a, b) for (int i = (a)-1; i >= (b); i--)\r\n#define ll long long\r\n#define ull unsigned long long\r\nint dx[4] = {1, 0, -1, 0};\r\nint dy[4] = {0, 1, 0, -1};\r\nconst int INF = 1e9;\r\nconst int MOD = 1e9 + 7;\r\nusing namespace std;\r\nint f_stamp[103];\r\nint e_stamp[103];\r\nvector<vector<int>> edge;\r\nint t;\r\nvoid dfs(int v) {\r\n  REP(i, edge[v].size()) {\r\n    if (not f_stamp[edge[v][i]]) {\r\n      f_stamp[edge[v][i]] = ++t;\r\n      dfs(edge[v][i]);\r\n    }\r\n  }\r\n  e_stamp[v] = ++t;\r\n}\r\nint main() {\r\n  cin.tie(0);\r\n  ios::sync_with_stdio(false);\r\n  int n;\r\n  cin >> n;\r\n  edge.resize(n, vector<int>());\r\n  REP(i, n) {\r\n    int v;\r\n    cin >> v;\r\n    v--;\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n      int u;\r\n      cin >> u;\r\n      u--;\r\n      edge[v].push_back(u);\r\n    }\r\n  }\r\n  REP(i, n) {\r\n    if (not f_stamp[i]) {\r\n      f_stamp[i] = ++t;\r\n      dfs(i);\r\n    }\r\n  }\r\n  REP(i, n) { cout << i + 1 << ' ' << f_stamp[i] << ' ' << e_stamp[i] << endl; }\r\n  return 0;\r\n}\r\n", "diff": "@@ -29,9 +29,9 @@\n vector<vector<int>> edge;\n int t;\n void dfs(int v) {\n+  f_stamp[v] = ++t;\n   REP(i, edge[v].size()) {\n     if (not f_stamp[edge[v][i]]) {\n-      f_stamp[edge[v][i]] = ++t;\n       dfs(edge[v][i]);\n     }\n   }\n@@ -58,7 +58,6 @@\n   }\n   REP(i, n) {\n     if (not f_stamp[i]) {\n-      f_stamp[i] = ++t;\n       dfs(i);\n     }\n   }", "predicted_diffs": [" - -38,8 +38,7 @@\n   }\n   return n;\n }\n-void dfs(int v, int e) {\n-  if (dfs(v, e) == e) {\n+  if (dfs(v, e) == e) {\n     cout << \"unreachable\" << endl;\n     return;\n   }"], "optimized_codes": ["#include <algorithm>\n#include <bitset>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define RREP(i, n) for (int i = (n)-1; i >= 0; i--)\n#define RFOR(i, a, b) for (int i = (a)-1; i >= (b); i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nusing namespace std;\nint f_stamp[103];\nint e_stamp[103];\nvector<vector<int>> edge;\nint t;\nvoid dfs(int v) {\n  REP(i, edge[v].size()) {\n    if (not f_stamp[edge[v][i]]) {\n      f_stamp[edge[v][i]] = ++t;\n      dfs(edge[v][i]);\n    }\n  }\n  e_stamp[v] = ++t;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  edge.resize(n, vector<int>());\n  REP(i, n) {\n    int v;\n    cin >> v;\n    v--;\n    int t;\n    cin >> t;\n    while (t--) {\n      int u;\n      cin >> u;\n      u--;\n      edge[v].push_back(u);\n    }\n  }\n  REP(i, n) {\n    if (not f_stamp[i]) {\n      f_stamp[i] = ++t;\n      dfs(i);\n    }\n  }\n  REP(i, n) { cout << i + 1 << ' ' << f_stamp[i] << ' ' << e_stamp[i] << endl; }\n  return 0;\n}"]}
{"problem_id": "p02315", "original": "#include <iostream>\r\n#define REP(i, n) for (int i = 0; i < n; i++)\r\nusing namespace std;\r\nint main(void) {\r\n  cin.tie(0);\r\n  ios::sync_with_stdio(false);\r\n  int N, W;\r\n  cin >> N >> W;\r\n  int value[N];\r\n  int weight[N];\r\n  REP(n, N) {\r\n    cin >> value[n];\r\n    cin >> weight[n];\r\n  }\r\n  int dp[110][11000] = {{}};\r\n  REP(n, N) {\r\n    REP(w, W + 1) {\r\n      weight[n] > w\r\n          ? dp[n + 1][w] = dp[n][w]\r\n          : dp[n + 1][w] = max(dp[n][w], dp[n][w - weight[n]] + value[n]);\r\n    }\r\n  }\r\n  cout << dp[N][W] << endl;\r\n  return 0;\r\n}\r\n", "diff": "@@ -12,7 +12,7 @@\n     cin >> value[n];\n     cin >> weight[n];\n   }\n-  int dp[110][11000] = {{}};\n+  int dp[101][10002] = {{}};\n   REP(n, N) {\n     REP(w, W + 1) {\n       weight[n] > w", "predicted_diffs": [" - -7,7 +7,7 @@\n   cin >> N >> W;\n   int value[n], weight[n];\n   cin >> value[n];\n-  REP(i, N) REP(j, W) dp[i][j] = i;\n+  REP(i, N) REP(j, W) dp[i][j] = i;\n   REP(n, N) {\n     cin >> value[n];\n     weight[n] = weight[n];"], "optimized_codes": ["#include <iostream>\n#define REP(i, n) for (int i = 0; i < n; i++)\nusing namespace std;\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int N, W;\n  cin >> N >> W;\n  int value[N];\n  int weight[N];\n  REP(n, N) {\n    cin >> value[n];\n    cin >> weight[n];\n  }\n  int dp[110][11000] = {{}};\n  REP(n, N) {\n    REP(w, W + 1) {\n      weight[n] > w\n          ? dp[n + 1][w] = dp[n][w]\n          : dp[n + 1][w] = max(dp[n][w], dp[n][w - weight[n]] + value[n]);\n    }\n  }\n  cout << dp[N][W] << endl;\n  return 0;\n}"]}
{"problem_id": "p00494", "original": "#include <algorithm>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <string>\r\nusing namespace std;\r\nchar x[1000005];\r\nint a = 0, b = 0, c = 0, d = 0, e, f, i, j, k, maxi = 0;\r\nint main() {\r\n  fill(x, x + 1000005, 'A');\r\n  scanf(\"%s\", x);\r\n  int leng = strlen(x);\r\n  while (1) {\r\n    if (a == leng) {\r\n      break;\r\n    }\r\n    if (x[a] != 'J') {\r\n      a++;\r\n    } else {\r\n      while (1) {\r\n        if (x[a] == 'J') {\r\n          b++;\r\n          a++;\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n      while (1) {\r\n        if (x[a] == 'O') {\r\n          c++;\r\n          a++;\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n      while (1) {\r\n        if (x[a] == 'I') {\r\n          d++;\r\n          a++;\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n      if (b >= c && c <= d) {\r\n        maxi = max(maxi, c);\r\n      }\r\n      b = 0;\r\n      c = 0;\r\n      d = 0;\r\n    }\r\n  }\r\n  printf(\"%d\\n\", maxi);\r\n  scanf(\"%d\", &a);\r\n  return 0;\r\n}\r\n", "diff": "@@ -6,7 +6,6 @@\n char x[1000005];\n int a = 0, b = 0, c = 0, d = 0, e, f, i, j, k, maxi = 0;\n int main() {\n-  fill(x, x + 1000005, 'A');\n   scanf(\"%s\", x);\n   int leng = strlen(x);\n   while (1) {", "predicted_diffs": [" - -3,7 +3,7 @@\n #include <string>\n using namespace std;\n char x[1000005], y[1000005];\n-int x[1000005], y[1000005];\n+int x[xx5], y[xx];\n int main() {\n   fill(x, x + 100000, 0);\n   scanf(\"%d %d\", &x, &y);"], "optimized_codes": ["#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <string>\nusing namespace std;\nchar x[1000005];\nint a = 0, b = 0, c = 0, d = 0, e, f, i, j, k, maxi = 0;\nint main() {\n  fill(x, x + 1000005, 'A');\n  scanf(\"%s\", x);\n  int leng = strlen(x);\n  while (1) {\n    if (a == leng) {\n      break;\n    }\n    if (x[a] != 'J') {\n      a++;\n    } else {\n      while (1) {\n        if (x[a] == 'J') {\n          b++;\n          a++;\n        } else {\n          break;\n        }\n      }\n      while (1) {\n        if (x[a] == 'O') {\n          c++;\n          a++;\n        } else {\n          break;\n        }\n      }\n      while (1) {\n        if (x[a] == 'I') {\n          d++;\n          a++;\n        } else {\n          break;\n        }\n      }\n      if (b >= c && c <= d) {\n        maxi = max(maxi, c);\n      }\n      b = 0;\n      c = 0;\n      d = 0;\n    }\n  }\n  printf(\"%d\\n\", maxi);\n  scanf(\"%d\", &a);\n  return 0;\n}"]}
{"problem_id": "p02269", "original": "#include <math.h>\r\n#include <stdio.h>\r\nmain() {\r\n  int i, j, n, code;\r\n  char cm[7], op, dict[262145];\r\n  for (i = 0, scanf(\"%d\", &n), scanf(\"%s\", cm); i < n; i++, scanf(\"%s\", cm)) {\r\n    for (j = code = op = 0; op != '\\n'; scanf(\"%c\", &op))\r\n      if (op == 'A')\r\n        code += 1 * pow(4, j++);\r\n      else if (op == 'C')\r\n        code += 2 * pow(4, j++);\r\n      else if (op == 'G')\r\n        code += 3 * pow(4, j++);\r\n      else if (op == 'T')\r\n        code += 4 * pow(4, j++);\r\n    if (cm[0] == 'i')\r\n      dict[code] = 1;\r\n    if (cm[0] == 'f')\r\n      dict[code] ? printf(\"yes\\n\") : printf(\"no\\n\");\r\n  }\r\n  return 0;\r\n}\r\n", "diff": "@@ -3,7 +3,7 @@\n main() {\n   int i, j, n, code;\n   char cm[7], op, dict[262145];\n-  for (i = 0, scanf(\"%d\", &n), scanf(\"%s\", cm); i < n; i++, scanf(\"%s\", cm)) {\n+  for (i = 0, scanf(\"%d %s\", &n, cm); i < n; i++, scanf(\"%s\", cm)) {\n     for (j = code = op = 0; op != '\\n'; scanf(\"%c\", &op))\n       if (op == 'A')\n         code += 1 * pow(4, j++);", "predicted_diffs": [" - -3,8 +3,7 @@\n main() {\n   int i, j, n, code;\n   char cm[7], op, dict[262145];\n-  for (i = 0, scanf(\"%d\", &n); i < n; i++) {\n-    scanf(\"%s\", cm);\n+  for (i = 0, scanf(\"%d\", &n), scanf(\"%s\", cm); i < n; i++, scanf(\"%s\", cm)) {\n     for (j = code = op = 0; op != '\\n'; scanf(\"%c\", &op))\n       if (op == 'A')\n         code += 1 * pow(4, j++);"], "optimized_codes": ["#include <math.h>\n#include <stdio.h>\nmain() {\n  int i, j, n, code;\n  char cm[7], op, dict[262145];\n  for (i = 0, scanf(\"%d\", &n), scanf(\"%s\", cm); i < n; i++, scanf(\"%s\", cm)) {\n    for (j = code = op = 0; op != '\\n'; scanf(\"%c\", &op))\n      if (op == 'A')\n        code += 1 * pow(4, j++);\n      else if (op == 'C')\n        code += 2 * pow(4, j++);\n      else if (op == 'G')\n        code += 3 * pow(4, j++);\n      else if (op == 'T')\n        code += 4 * pow(4, j++);\n    if (cm[0] == 'i')\n      dict[code] = 1;\n    if (cm[0] == 'f')\n      dict[code] ? printf(\"yes\\n\") : printf(\"no\\n\");\n  }\n  return 0;\n}"]}
{"problem_id": "p02412", "original": "#include <stdio.h>\r\nint main() {\r\n  unsigned short set;\r\n  unsigned long tag;\r\n  signed short mid;\r\n  unsigned short agg[100];\r\n  int i, j;\r\n  int input_count = 0;\r\n  int num_count = 0;\r\n  for (i = 0; i < 100; i++) {\r\n    agg[i] = 0;\r\n  }\r\n  while (1) {\r\n    scanf(\"%d %ld\", &set, &tag);\r\n    if (set == 0 && tag == 0) {\r\n      break;\r\n    }\r\n    num_count = 0;\r\n    for (i = 1; i < set; i++) {\r\n      for (j = i; j <= set; j++) {\r\n        mid = tag - (i + j);\r\n        if (mid > i && mid < j) {\r\n          num_count++;\r\n        }\r\n      }\r\n    }\r\n    agg[input_count] = num_count;\r\n    input_count++;\r\n  }\r\n  for (i = 0; i < input_count; i++) {\r\n    printf(\"%d\\n\", agg[i]);\r\n  }\r\n  return 0;\r\n}\r\n", "diff": "@@ -4,9 +4,9 @@\n   unsigned long tag;\n   signed short mid;\n   unsigned short agg[100];\n-  int i, j;\n-  int input_count = 0;\n-  int num_count = 0;\n+  unsigned short i, j;\n+  unsigned short input_count = 0;\n+  unsigned short num_count = 0;\n   for (i = 0; i < 100; i++) {\n     agg[i] = 0;\n   }", "predicted_diffs": [" - -2,8 +2,8 @@\n int main() {\n   unsigned short set;\n   unsigned long tag;\n-  unsigned short mid;\n-  int agg[100];\n+  signed short mid;\n+  unsigned short agg[100];\n   int i, j;\n   int input_count = 0;\n   int num_count = 0;"], "optimized_codes": ["#include <stdio.h>\nint main() {\n  unsigned short set;\n  unsigned long tag;\n  signed short mid;\n  unsigned short agg[100];\n  int i, j;\n  int input_count = 0;\n  int num_count = 0;\n  for (i = 0; i < 100; i++) {\n    agg[i] = 0;\n  }\n  while (1) {\n    scanf(\"%d %ld\", &set, &tag);\n    if (set == 0 && tag == 0) {\n      break;\n    }\n    num_count = 0;\n    for (i = 1; i < set; i++) {\n      for (j = i; j <= set; j++) {\n        mid = tag - (i + j);\n        if (mid > i && mid < j) {\n          num_count++;\n        }\n      }\n    }\n    agg[input_count] = num_count;\n    input_count++;\n  }\n  for (i = 0; i < input_count; i++) {\n    printf(\"%d\\n\", agg[i]);\n  }\n  return 0;\n}"]}
{"problem_id": "p02274", "original": "#include <stdio.h>\r\nlong cnt = 0;\r\nvoid merge(int a[], int left, int mid, int right) {\r\n  int n1 = mid - left;\r\n  int n2 = right - mid;\r\n  int L[2000001];\r\n  int R[2000001];\r\n  for (int i = 0; i < n1; i++) {\r\n    L[i] = a[left + i];\r\n  }\r\n  for (int i = 0; i < n2; i++) {\r\n    R[i] = a[mid + i];\r\n  }\r\n  L[n1] = 1000000001;\r\n  R[n2] = 1000000001;\r\n  int i = 0;\r\n  int j = 0;\r\n  for (int k = left; k < right; k++) {\r\n    if (L[i] <= R[j]) {\r\n      a[k] = L[i++];\r\n    } else {\r\n      a[k] = R[j++];\r\n      cnt += n1 - i;\r\n    }\r\n  }\r\n}\r\nvoid mergeSort(int a[], int left, int right) {\r\n  int mid = 0;\r\n  mid = (left + right) / 2;\r\n  if (left + 1 < right) {\r\n    mergeSort(a, left, mid);\r\n    mergeSort(a, mid, right);\r\n    merge(a, left, mid, right);\r\n  }\r\n}\r\nint main() {\r\n  int n;\r\n  scanf(\"%d\\n\", &n);\r\n  int a[n];\r\n  for (int i = 0; i < n; i++) {\r\n    scanf(\"%d\", &a[i]);\r\n  }\r\n  mergeSort(a, 0, n);\r\n  printf(\"%ld\\n\", cnt);\r\n  return 0;\r\n}\r\n", "diff": "@@ -3,16 +3,16 @@\n void merge(int a[], int left, int mid, int right) {\n   int n1 = mid - left;\n   int n2 = right - mid;\n-  int L[2000001];\n-  int R[2000001];\n+  int L[2000000];\n+  int R[2000000];\n   for (int i = 0; i < n1; i++) {\n     L[i] = a[left + i];\n   }\n   for (int i = 0; i < n2; i++) {\n     R[i] = a[mid + i];\n   }\n-  L[n1] = 1000000001;\n-  R[n2] = 1000000001;\n+  L[n1] = 1000000000;\n+  R[n2] = 1000000000;\n   int i = 0;\n   int j = 0;\n   for (int k = left; k < right; k++) {", "predicted_diffs": [" - -9,7 +9,7 @@\n   for (int i = 0; i < n2; i++) {\n     R[i] = a[mid + i];\n   }\n-  L[n1] = 1000000001;\n+  L[n2] = 1000000001;\n   int i = 0;\n   int j = 0;\n   for (int k = left; k < right; k++) {"], "optimized_codes": ["#include <stdio.h>\nlong cnt = 0;\nvoid merge(int a[], int left, int mid, int right) {\n  int n1 = mid - left;\n  int n2 = right - mid;\n  int L[2000001];\n  int R[2000001];\n  for (int i = 0; i < n1; i++) {\n    L[i] = a[left + i];\n  }\n  for (int i = 0; i < n2; i++) {\n    R[i] = a[mid + i];\n  }\n  L[n1] = 1000000001;\n  R[n2] = 1000000001;\n  int i = 0;\n  int j = 0;\n  for (int k = left; k < right; k++) {\n    if (L[i] <= R[j]) {\n      a[k] = L[i++];\n    } else {\n      a[k] = R[j++];\n      cnt += n1 - i;\n    }\n  }\n}\nvoid mergeSort(int a[], int left, int right) {\n  int mid = 0;\n  mid = (left + right) / 2;\n  if (left + 1 < right) {\n    mergeSort(a, left, mid);\n    mergeSort(a, mid, right);\n    merge(a, left, mid, right);\n  }\n}\nint main() {\n  int n;\n  scanf(\"%d\\n\", &n);\n  int a[n];\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  mergeSort(a, 0, n);\n  printf(\"%ld\\n\", cnt);\n  return 0;\n}"]}
{"problem_id": "p01415", "original": "#include <bits/stdc++.h>\r\n#define M 10001\r\nusing namespace std;\r\nlong long n, k, t, u, v, l, d, c, x, a, s[M];\r\nint main() {\r\n  cin >> n >> k >> t >> u >> v >> l;\r\n  for (int i = 0; i < n; i++)\r\n    cin >> d, s[d] = 1;\r\n  for (int i = 0; i < l; i++) {\r\n    if (s[i])\r\n      if (!x || k == c)\r\n        x = v * t;\r\n      else\r\n        c++;\r\n    else if (!x && c)\r\n      c--, x = v * t;\r\n    if (x)\r\n      a++, x--;\r\n  }\r\n  printf(\"%.8f\\n\", a * 1.0 / v + (l - a) * 1.0 / u);\r\n  return 0;\r\n}\r\n", "diff": "@@ -1,7 +1,7 @@\n #include <bits/stdc++.h>\n #define M 10001\n using namespace std;\n-long long n, k, t, u, v, l, d, c, x, a, s[M];\n+int n, k, t, u, v, l, d, c, x, a, s[M];\n int main() {\n   cin >> n >> k >> t >> u >> v >> l;\n   for (int i = 0; i < n; i++)", "predicted_diffs": [" - -1,5 +1,5 @@\n #include <bits/stdc++.h>\n-#define M 10001\n+#define M 50\n using namespace std;\n long long n, k, t, u, v, c;\n int main() {"], "optimized_codes": ["#include <bits/stdc++.h>\n#define M 10001\nusing namespace std;\nlong long n, k, t, u, v, l, d, c, x, a, s[M];\nint main() {\n  cin >> n >> k >> t >> u >> v >> l;\n  for (int i = 0; i < n; i++)\n    cin >> d, s[d] = 1;\n  for (int i = 0; i < l; i++) {\n    if (s[i])\n      if (!x || k == c)\n        x = v * t;\n      else\n        c++;\n    else if (!x && c)\n      c--, x = v * t;\n    if (x)\n      a++, x--;\n  }\n  printf(\"%.8f\\n\", a * 1.0 / v + (l - a) * 1.0 / u);\n  return 0;\n}"]}
{"problem_id": "p00909", "original": "#include <algorithm>\r\n#include <cassert>\r\n#include <iostream>\r\n#define REP(i, s, n) for (int i = s; i < n; i++)\r\n#define rep(i, n) REP(i, 0, n)\r\n#define inf (1 << 29)\r\n#define MAX 3000000\r\nusing namespace std;\r\ntypedef long long ll;\r\nstruct P {\r\n  ll color, w;\r\n  P(ll color = -inf, ll w = -inf) : color(color), w(w) {}\r\n};\r\nP par[MAX];\r\nvoid init() { rep(i, MAX) par[i] = P(i); }\r\nP find(int x) {\r\n  if (x == par[x].color)\r\n    return par[x];\r\n  P p = find(par[x].color);\r\n  if (par[x].w == -inf)\r\n    par[x].w = 0;\r\n  par[x].w += p.w, par[x].color = p.color;\r\n  return par[x];\r\n}\r\nvoid unit(int x, int y, ll w) {\r\n  P X = find(x);\r\n  P Y = find(y);\r\n  par[X.color].color = par[Y.color].color;\r\n  if (par[X.color].w == -inf)\r\n    par[X.color].w = 0;\r\n  if (par[Y.color].w == -inf)\r\n    par[Y.color].w = 0;\r\n  par[X.color].w = par[X.color].w + (par[y].w - w - par[x].w);\r\n}\r\nint N, M;\r\nint main() {\r\n  while (cin >> N >> M, N | M) {\r\n    init();\r\n    char c;\r\n    ll a, b, w;\r\n    rep(_, M) {\r\n      cin >> c;\r\n      if (c == '!') {\r\n        cin >> a >> b >> w;\r\n        unit(a, b, w);\r\n      } else {\r\n        cin >> a >> b;\r\n        P B = find(b);\r\n        P A = find(a);\r\n        if (B.color != A.color)\r\n          cout << \"UNKNOWN\" << endl;\r\n        else\r\n          cout << B.w - A.w << endl;\r\n      }\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n", "diff": "@@ -6,10 +6,9 @@\n #define inf (1 << 29)\n #define MAX 3000000\n using namespace std;\n-typedef long long ll;\n struct P {\n-  ll color, w;\n-  P(ll color = -inf, ll w = -inf) : color(color), w(w) {}\n+  int color, w;\n+  P(int color = -inf, int w = -inf) : color(color), w(w) {}\n };\n P par[MAX];\n void init() { rep(i, MAX) par[i] = P(i); }\n@@ -22,7 +21,7 @@\n   par[x].w += p.w, par[x].color = p.color;\n   return par[x];\n }\n-void unit(int x, int y, ll w) {\n+void unit(int x, int y, int w) {\n   P X = find(x);\n   P Y = find(y);\n   par[X.color].color = par[Y.color].color;\n@@ -37,7 +36,7 @@\n   while (cin >> N >> M, N | M) {\n     init();\n     char c;\n-    ll a, b, w;\n+    int a, b, w;\n     rep(_, M) {\n       cin >> c;\n       if (c == '!') {", "predicted_diffs": [" - -47,14 +47,11 @@\n         cin >> a >> b;\n         P B = find(b);\n         P A = find(a);\n-        if (B.w == -inf || A.w == -inf)\n-          cout << \"UNKNOWN\" << endl;\n-        else if (B.color != A.color)\n+        if (B.color != A.color)\n           cout << \"UNKNOWN\" << endl;\n         else\n           cout << B.w - A.w << endl;\n       }\n-      rep(i, 10) {}\n     }\n   }\n   return 0;"], "optimized_codes": ["#include <algorithm>\n#include <cassert>\n#include <iostream>\n#define REP(i, s, n) for (int i = s; i < n; i++)\n#define rep(i, n) REP(i, 0, n)\n#define inf (1 << 29)\n#define MAX 3000000\nusing namespace std;\ntypedef long long ll;\nstruct P {\n  ll color, w;\n  P(ll color = -inf, ll w = -inf) : color(color), w(w) {}\n};\nP par[MAX];\nvoid init() { rep(i, MAX) par[i] = P(i); }\nP find(int x) {\n  if (x == par[x].color)\n    return par[x];\n  P p = find(par[x].color);\n  if (par[x].w == -inf)\n    par[x].w = 0;\n  par[x].w += p.w, par[x].color = p.color;\n  return par[x];\n}\nvoid unit(int x, int y, ll w) {\n  P X = find(x);\n  P Y = find(y);\n  par[X.color].color = par[Y.color].color;\n  if (par[X.color].w == -inf)\n    par[X.color].w = 0;\n  if (par[Y.color].w == -inf)\n    par[Y.color].w = 0;\n  par[X.color].w = par[X.color].w + (par[y].w - w - par[x].w);\n}\nint N, M;\nint main() {\n  while (cin >> N >> M, N | M) {\n    init();\n    char c;\n    ll a, b, w;\n    rep(_, M) {\n      cin >> c;\n      if (c == '!') {\n        cin >> a >> b >> w;\n        unit(a, b, w);\n      } else {\n        cin >> a >> b;\n        P B = find(b);\n        P A = find(a);\n        if (B.color != A.color)\n          cout << \"UNKNOWN\" << endl;\n        else\n          cout << B.w - A.w << endl;\n      }\n    }\n  }\n  return 0;\n}"]}
{"problem_id": "p01448", "original": "#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\ntemplate <class T> struct SegmentTree {\r\n  vector<T> nodes, stocks;\r\n  int size;\r\n  SegmentTree(int size) : size(size) {\r\n    nodes.resize(size * 4, 0);\r\n    stocks.resize(size * 4, 0);\r\n  }\r\n  void maintain_consistency(int pos) {\r\n    if (stocks[pos] > 0) {\r\n      stocks[pos * 2 + 1] += stocks[pos] / 2;\r\n      stocks[pos * 2 + 2] += stocks[pos] / 2;\r\n      nodes[pos] += stocks[pos];\r\n      stocks[pos] = 0;\r\n    }\r\n  }\r\n  T get_inner(int left, int right, int pos, int pl, int pr) {\r\n    if (pr <= left || right <= pl)\r\n      return 0;\r\n    if (left <= pl && pr <= right)\r\n      return nodes[pos] + stocks[pos];\r\n    maintain_consistency(pos);\r\n    const int center = (pl + pr) / 2;\r\n    T lv = get_inner(left, right, pos * 2 + 1, pl, center);\r\n    T rv = get_inner(left, right, pos * 2 + 2, center, pr);\r\n    return lv + rv;\r\n  }\r\n  T get(int left, int right) { return get_inner(left, right, 0, 0, size); }\r\n  T add_inner(int left, int right, int pos, int pl, int pr) {\r\n    if (pr <= left || right <= pl)\r\n      return stocks[pos] + nodes[pos];\r\n    if (left <= pl && pr <= right) {\r\n      stocks[pos] += pr - pl;\r\n      return stocks[pos] + nodes[pos];\r\n    }\r\n    maintain_consistency(pos);\r\n    const int center = (pl + pr) / 2;\r\n    T lv = add_inner(left, right, pos * 2 + 1, pl, center);\r\n    T rv = add_inner(left, right, pos * 2 + 2, center, pr);\r\n    return nodes[pos] = lv + rv;\r\n  }\r\n  T add(int left, int right) { return add_inner(left, right, 0, 0, size); }\r\n};\r\nint main() {\r\n  cin.tie(0);\r\n  ios::sync_with_stdio(0);\r\n  int N;\r\n  cin >> N;\r\n  SegmentTree<int> segtree(1 << 20);\r\n  for (int i = 0; i < N; ++i) {\r\n    int minval, maxval;\r\n    cin >> minval >> maxval;\r\n    segtree.add(minval - 1, maxval);\r\n  }\r\n  int ans = 0;\r\n  for (int n = N; n >= 0; --n) {\r\n    const int val = segtree.get(n, n + 1);\r\n    if (val >= n) {\r\n      ans = n;\r\n      break;\r\n    }\r\n  }\r\n  cout << ans << endl;\r\n  return 0;\r\n}\r\n", "diff": "@@ -10,8 +10,10 @@\n   }\n   void maintain_consistency(int pos) {\n     if (stocks[pos] > 0) {\n-      stocks[pos * 2 + 1] += stocks[pos] / 2;\n-      stocks[pos * 2 + 2] += stocks[pos] / 2;\n+      if (pos * 2 + 1 < stocks.size())\n+        stocks[pos * 2 + 1] += stocks[pos] / 2;\n+      if (pos * 2 + 2 < stocks.size())\n+        stocks[pos * 2 + 2] += stocks[pos] / 2;\n       nodes[pos] += stocks[pos];\n       stocks[pos] = 0;\n     }", "predicted_diffs": [" - -13,7 +13,7 @@\n     return 0;\n   }\n   void update(int pos, int val) {\n-    pos++;\n+    pos = min(pos, val);\n     return;\n   }\n   int getSize(int pos) { return sum(pos) + sum(pos - 1); }"], "optimized_codes": ["#include <iostream>\n#include <vector>\nusing namespace std;\ntemplate <class T> struct SegmentTree {\n  vector<T> nodes, stocks;\n  int size;\n  SegmentTree(int size) : size(size) {\n    nodes.resize(size * 4, 0);\n    stocks.resize(size * 4, 0);\n  }\n  void maintain_consistency(int pos) {\n    if (stocks[pos] > 0) {\n      stocks[pos * 2 + 1] += stocks[pos] / 2;\n      stocks[pos * 2 + 2] += stocks[pos] / 2;\n      nodes[pos] += stocks[pos];\n      stocks[pos] = 0;\n    }\n  }\n  T get_inner(int left, int right, int pos, int pl, int pr) {\n    if (pr <= left || right <= pl)\n      return 0;\n    if (left <= pl && pr <= right)\n      return nodes[pos] + stocks[pos];\n    maintain_consistency(pos);\n    const int center = (pl + pr) / 2;\n    T lv = get_inner(left, right, pos * 2 + 1, pl, center);\n    T rv = get_inner(left, right, pos * 2 + 2, center, pr);\n    return lv + rv;\n  }\n  T get(int left, int right) { return get_inner(left, right, 0, 0, size); }\n  T add_inner(int left, int right, int pos, int pl, int pr) {\n    if (pr <= left || right <= pl)\n      return stocks[pos] + nodes[pos];\n    if (left <= pl && pr <= right) {\n      stocks[pos] += pr - pl;\n      return stocks[pos] + nodes[pos];\n    }\n    maintain_consistency(pos);\n    const int center = (pl + pr) / 2;\n    T lv = add_inner(left, right, pos * 2 + 1, pl, center);\n    T rv = add_inner(left, right, pos * 2 + 2, center, pr);\n    return nodes[pos] = lv + rv;\n  }\n  T add(int left, int right) { return add_inner(left, right, 0, 0, size); }\n};\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int N;\n  cin >> N;\n  SegmentTree<int> segtree(1 << 20);\n  for (int i = 0; i < N; ++i) {\n    int minval, maxval;\n    cin >> minval >> maxval;\n    segtree.add(minval - 1, maxval);\n  }\n  int ans = 0;\n  for (int n = N; n >= 0; --n) {\n    const int val = segtree.get(n, n + 1);\n    if (val >= n) {\n      ans = n;\n      break;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"]}
{"problem_id": "p01361", "original": "#include <algorithm>\r\n#include <cstring>\r\n#include <fstream>\r\n#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\nint dy[201];\r\nint dx[201];\r\nint dp[2][1 << 12];\r\nchar field[101][101];\r\nint dmg[201];\r\nint stepDmg[2001];\r\nint portions[101];\r\nint inithp;\r\nint maxhp;\r\nint r, c;\r\nint step;\r\nint S, P, T;\r\nconst int INF = 1000000000LL;\r\nvoid input() {\r\n  cin >> r >> c;\r\n  for (int i = 0; i < r; i++)\r\n    for (int j = 0; j < c; j++)\r\n      cin >> field[i][j];\r\n  cin >> T;\r\n  for (int i = 0; i < T; i++) {\r\n    char ch;\r\n    int m;\r\n    cin >> ch >> m;\r\n    dmg[ch] = m;\r\n  }\r\n  cin >> S;\r\n  int cx = 0;\r\n  int cy = 0;\r\n  for (int i = 0; i < S; i++) {\r\n    char ch;\r\n    int quan;\r\n    cin >> ch >> quan;\r\n    for (int j = 0; j < quan; j++) {\r\n      int ny = cy + dy[ch];\r\n      int nx = cx + dx[ch];\r\n      stepDmg[step] = dmg[field[ny][nx]];\r\n      step++;\r\n      cx = nx;\r\n      cy = ny;\r\n    }\r\n  }\r\n  cin >> P;\r\n  for (int i = 0; i < P; i++)\r\n    cin >> portions[i];\r\n}\r\nint main() {\r\n  dy['U'] = -1;\r\n  dx['U'] = 0;\r\n  dy['R'] = 0;\r\n  dx['R'] = 1;\r\n  dy['D'] = 1;\r\n  dx['D'] = 0;\r\n  dy['L'] = 0;\r\n  dx['L'] = -1;\r\n  while (cin >> inithp >> maxhp && (inithp | maxhp)) {\r\n    step = 0;\r\n    input();\r\n    for (int j = 0; j < (1 << P); j++) {\r\n      int sum = 0;\r\n      for (int i = 0; i < P; i++)\r\n        if (!((j >> i) & 1))\r\n          sum += portions[i];\r\n      dp[0][j] = min(maxhp, sum + inithp);\r\n    }\r\n    for (int i = 0; i < step; i++) {\r\n      int nxt = (i + 1) % 2;\r\n      int cur = i % 2;\r\n      for (int j = (1 << P) - 1; j >= 0; j--) {\r\n        int res = -INF;\r\n        int s = j;\r\n        int pos = i;\r\n        for (int k = 0; k < P; k++)\r\n          if (!((s >> k) & 1) && dp[nxt][s | (1 << k)] > 0) {\r\n            res = max(res, min(dp[nxt][s | (1 << k)] + portions[k], maxhp));\r\n          }\r\n        res = max(res, dp[cur][s] - stepDmg[pos]);\r\n        if (res < 0)\r\n          res = -INF;\r\n        dp[nxt][s] = min(maxhp, res);\r\n      }\r\n    }\r\n    bool ok = false;\r\n    for (int j = 0; j < (1 << P); j++)\r\n      if (dp[step % 2][j] > 0)\r\n        ok = true;\r\n    if (ok)\r\n      cout << \"YES\" << endl;\r\n    else\r\n      cout << \"NO\" << endl;\r\n  }\r\n  return 0;\r\n}\r\n", "diff": "@@ -76,11 +76,10 @@\n         int s = j;\n         int pos = i;\n         for (int k = 0; k < P; k++)\n-          if (!((s >> k) & 1) && dp[nxt][s | (1 << k)] > 0) {\n+          if (!((s >> k) & 1))\n             res = max(res, min(dp[nxt][s | (1 << k)] + portions[k], maxhp));\n-          }\n         res = max(res, dp[cur][s] - stepDmg[pos]);\n-        if (res < 0)\n+        if (res <= 0)\n           res = -INF;\n         dp[nxt][s] = min(maxhp, res);\n       }", "predicted_diffs": [" - -75,7 +75,7 @@\n     cin >> ch >> P;\n     if (ch == '?')\n       break;\n-    for (int i = 0; i < r; i++) {\n+    for (int i = 0; i < r; i++) {\n       int cn = S[i];\n       cn /= P;\n       cn *= P;"], "optimized_codes": ["#include <algorithm>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <vector>\nusing namespace std;\nint dy[201];\nint dx[201];\nint dp[2][1 << 12];\nchar field[101][101];\nint dmg[201];\nint stepDmg[2001];\nint portions[101];\nint inithp;\nint maxhp;\nint r, c;\nint step;\nint S, P, T;\nconst int INF = 1000000000LL;\nvoid input() {\n  cin >> r >> c;\n  for (int i = 0; i < r; i++)\n    for (int j = 0; j < c; j++)\n      cin >> field[i][j];\n  cin >> T;\n  for (int i = 0; i < T; i++) {\n    char ch;\n    int m;\n    cin >> ch >> m;\n    dmg[ch] = m;\n  }\n  cin >> S;\n  int cx = 0;\n  int cy = 0;\n  for (int i = 0; i < S; i++) {\n    char ch;\n    int quan;\n    cin >> ch >> quan;\n    for (int j = 0; j < quan; j++) {\n      int ny = cy + dy[ch];\n      int nx = cx + dx[ch];\n      stepDmg[step] = dmg[field[ny][nx]];\n      step++;\n      cx = nx;\n      cy = ny;\n    }\n  }\n  cin >> P;\n  for (int i = 0; i < P; i++)\n    cin >> portions[i];\n}\nint main() {\n  dy['U'] = -1;\n  dx['U'] = 0;\n  dy['R'] = 0;\n  dx['R'] = 1;\n  dy['D'] = 1;\n  dx['D'] = 0;\n  dy['L'] = 0;\n  dx['L'] = -1;\n  while (cin >> inithp >> maxhp && (inithp | maxhp)) {\n    step = 0;\n    input();\n    for (int j = 0; j < (1 << P); j++) {\n      int sum = 0;\n      for (int i = 0; i < P; i++)\n        if (!((j >> i) & 1))\n          sum += portions[i];\n      dp[0][j] = min(maxhp, sum + inithp);\n    }\n    for (int i = 0; i < step; i++) {\n      int nxt = (i + 1) % 2;\n      int cur = i % 2;\n      for (int j = (1 << P) - 1; j >= 0; j--) {\n        int res = -INF;\n        int s = j;\n        int pos = i;\n        for (int k = 0; k < P; k++)\n          if (!((s >> k) & 1) && dp[nxt][s | (1 << k)] > 0) {\n            res = max(res, min(dp[nxt][s | (1 << k)] + portions[k], maxhp));\n          }\n        res = max(res, dp[cur][s] - stepDmg[pos]);\n        if (res < 0)\n          res = -INF;\n        dp[nxt][s] = min(maxhp, res);\n      }\n    }\n    bool ok = false;\n    for (int j = 0; j < (1 << P); j++)\n      if (dp[step % 2][j] > 0)\n        ok = true;\n    if (ok)\n      cout << \"YES\" << endl;\n    else\n      cout << \"NO\" << endl;\n  }\n  return 0;\n}"]}
